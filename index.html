

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RoMa: A lightweight library to deal with 3D rotations in PyTorch. &mdash; RoMa latest documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=c6e86fd7"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="#" class="icon icon-home">
            RoMa
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">RoMa: A lightweight library to deal with 3D rotations in PyTorch.</a><ul>
<li><a class="reference internal" href="#installation">Installation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#main-features">Main features</a><ul>
<li><a class="reference internal" href="#supported-rotation-representations">Supported rotation representations</a></li>
<li><a class="reference internal" href="#mappings-between-rotation-representations">Mappings between rotation representations</a></li>
<li><a class="reference internal" href="#mappings-from-euclidean-to-3d-rotation-space">Mappings from Euclidean to 3D rotation space</a></li>
<li><a class="reference internal" href="#support-for-an-arbitrary-number-of-batch-dimensions">Support for an arbitrary number of batch dimensions</a></li>
<li><a class="reference internal" href="#quaternion-operations">Quaternion operations</a></li>
<li><a class="reference internal" href="#rotation-composition-and-inverse">Rotation composition and inverse</a></li>
<li><a class="reference internal" href="#rotation-metrics">Rotation metrics</a></li>
<li><a class="reference internal" href="#weighted-rotation-averaging">Weighted rotation averaging</a></li>
<li><a class="reference internal" href="#rigid-registration">Rigid registration</a></li>
<li><a class="reference internal" href="#spherical-linear-interpolation-slerp">Spherical linear interpolation (SLERP)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#why-a-new-library">Why a new library?</a></li>
<li><a class="reference internal" href="#api-documentation">API Documentation</a><ul>
<li><a class="reference internal" href="#module-roma.mappings">Mappings</a><ul>
<li><a class="reference internal" href="#roma.mappings.procrustes"><code class="docutils literal notranslate"><span class="pre">procrustes()</span></code></a></li>
<li><a class="reference internal" href="#roma.mappings.procrustes_naive"><code class="docutils literal notranslate"><span class="pre">procrustes_naive()</span></code></a></li>
<li><a class="reference internal" href="#roma.mappings.quat_wxyz_to_xyzw"><code class="docutils literal notranslate"><span class="pre">quat_wxyz_to_xyzw()</span></code></a></li>
<li><a class="reference internal" href="#roma.mappings.quat_xyzw_to_wxyz"><code class="docutils literal notranslate"><span class="pre">quat_xyzw_to_wxyz()</span></code></a></li>
<li><a class="reference internal" href="#roma.mappings.rotmat_to_rotvec"><code class="docutils literal notranslate"><span class="pre">rotmat_to_rotvec()</span></code></a></li>
<li><a class="reference internal" href="#roma.mappings.rotmat_to_unitquat"><code class="docutils literal notranslate"><span class="pre">rotmat_to_unitquat()</span></code></a></li>
<li><a class="reference internal" href="#roma.mappings.rotvec_to_rotmat"><code class="docutils literal notranslate"><span class="pre">rotvec_to_rotmat()</span></code></a></li>
<li><a class="reference internal" href="#roma.mappings.rotvec_to_unitquat"><code class="docutils literal notranslate"><span class="pre">rotvec_to_unitquat()</span></code></a></li>
<li><a class="reference internal" href="#roma.mappings.special_gramschmidt"><code class="docutils literal notranslate"><span class="pre">special_gramschmidt()</span></code></a></li>
<li><a class="reference internal" href="#roma.mappings.special_procrustes"><code class="docutils literal notranslate"><span class="pre">special_procrustes()</span></code></a></li>
<li><a class="reference internal" href="#roma.mappings.special_procrustes_naive"><code class="docutils literal notranslate"><span class="pre">special_procrustes_naive()</span></code></a></li>
<li><a class="reference internal" href="#roma.mappings.symmatrix_to_projective_point"><code class="docutils literal notranslate"><span class="pre">symmatrix_to_projective_point()</span></code></a></li>
<li><a class="reference internal" href="#roma.mappings.symmatrixvec_to_unitquat"><code class="docutils literal notranslate"><span class="pre">symmatrixvec_to_unitquat()</span></code></a></li>
<li><a class="reference internal" href="#roma.mappings.unitquat_to_rotmat"><code class="docutils literal notranslate"><span class="pre">unitquat_to_rotmat()</span></code></a></li>
<li><a class="reference internal" href="#roma.mappings.unitquat_to_rotvec"><code class="docutils literal notranslate"><span class="pre">unitquat_to_rotvec()</span></code></a></li>
<li><a class="reference internal" href="#roma.euler.euler_to_rotmat"><code class="docutils literal notranslate"><span class="pre">euler_to_rotmat()</span></code></a></li>
<li><a class="reference internal" href="#roma.euler.euler_to_rotvec"><code class="docutils literal notranslate"><span class="pre">euler_to_rotvec()</span></code></a></li>
<li><a class="reference internal" href="#roma.euler.euler_to_unitquat"><code class="docutils literal notranslate"><span class="pre">euler_to_unitquat()</span></code></a></li>
<li><a class="reference internal" href="#roma.euler.rotmat_to_euler"><code class="docutils literal notranslate"><span class="pre">rotmat_to_euler()</span></code></a></li>
<li><a class="reference internal" href="#roma.euler.rotvec_to_euler"><code class="docutils literal notranslate"><span class="pre">rotvec_to_euler()</span></code></a></li>
<li><a class="reference internal" href="#roma.euler.unitquat_to_euler"><code class="docutils literal notranslate"><span class="pre">unitquat_to_euler()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-roma.utils">Utils</a><ul>
<li><a class="reference internal" href="#roma.utils.identity_quat"><code class="docutils literal notranslate"><span class="pre">identity_quat()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.is_orthonormal_matrix"><code class="docutils literal notranslate"><span class="pre">is_orthonormal_matrix()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.is_rotation_matrix"><code class="docutils literal notranslate"><span class="pre">is_rotation_matrix()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.is_torch_batch_svd_available"><code class="docutils literal notranslate"><span class="pre">is_torch_batch_svd_available()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.quat_action"><code class="docutils literal notranslate"><span class="pre">quat_action()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.quat_composition"><code class="docutils literal notranslate"><span class="pre">quat_composition()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.quat_conjugation"><code class="docutils literal notranslate"><span class="pre">quat_conjugation()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.quat_inverse"><code class="docutils literal notranslate"><span class="pre">quat_inverse()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.quat_normalize"><code class="docutils literal notranslate"><span class="pre">quat_normalize()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.quat_product"><code class="docutils literal notranslate"><span class="pre">quat_product()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.random_rotmat"><code class="docutils literal notranslate"><span class="pre">random_rotmat()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.random_rotvec"><code class="docutils literal notranslate"><span class="pre">random_rotvec()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.random_unitquat"><code class="docutils literal notranslate"><span class="pre">random_unitquat()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.rigid_points_registration"><code class="docutils literal notranslate"><span class="pre">rigid_points_registration()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.rigid_vectors_registration"><code class="docutils literal notranslate"><span class="pre">rigid_vectors_registration()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.rotmat_composition"><code class="docutils literal notranslate"><span class="pre">rotmat_composition()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.rotmat_cosine_angle"><code class="docutils literal notranslate"><span class="pre">rotmat_cosine_angle()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.rotmat_geodesic_distance"><code class="docutils literal notranslate"><span class="pre">rotmat_geodesic_distance()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.rotmat_geodesic_distance_naive"><code class="docutils literal notranslate"><span class="pre">rotmat_geodesic_distance_naive()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.rotmat_inverse"><code class="docutils literal notranslate"><span class="pre">rotmat_inverse()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.rotmat_slerp"><code class="docutils literal notranslate"><span class="pre">rotmat_slerp()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.rotvec_composition"><code class="docutils literal notranslate"><span class="pre">rotvec_composition()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.rotvec_geodesic_distance"><code class="docutils literal notranslate"><span class="pre">rotvec_geodesic_distance()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.rotvec_inverse"><code class="docutils literal notranslate"><span class="pre">rotvec_inverse()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.rotvec_slerp"><code class="docutils literal notranslate"><span class="pre">rotvec_slerp()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.unitquat_geodesic_distance"><code class="docutils literal notranslate"><span class="pre">unitquat_geodesic_distance()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.unitquat_slerp"><code class="docutils literal notranslate"><span class="pre">unitquat_slerp()</span></code></a></li>
<li><a class="reference internal" href="#roma.utils.unitquat_slerp_fast"><code class="docutils literal notranslate"><span class="pre">unitquat_slerp_fast()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-roma.transforms">Spatial transformations</a><ul>
<li><a class="reference internal" href="#example-of-use">Example of use</a></li>
<li><a class="reference internal" href="#applying-a-transformation">Applying a transformation</a></li>
<li><a class="reference internal" href="#aliasing-issues">Aliasing issues</a></li>
<li><a class="reference internal" href="#roma.transforms.Affine"><code class="docutils literal notranslate"><span class="pre">Affine</span></code></a><ul>
<li><a class="reference internal" href="#roma.transforms.Affine.apply"><code class="docutils literal notranslate"><span class="pre">Affine.apply()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Affine.as_tuple"><code class="docutils literal notranslate"><span class="pre">Affine.as_tuple()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Affine.clone"><code class="docutils literal notranslate"><span class="pre">Affine.clone()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Affine.compose"><code class="docutils literal notranslate"><span class="pre">Affine.compose()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Affine.from_homogeneous"><code class="docutils literal notranslate"><span class="pre">Affine.from_homogeneous()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Affine.inverse"><code class="docutils literal notranslate"><span class="pre">Affine.inverse()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Affine.linear_apply"><code class="docutils literal notranslate"><span class="pre">Affine.linear_apply()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Affine.linear_compose"><code class="docutils literal notranslate"><span class="pre">Affine.linear_compose()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Affine.linear_inverse"><code class="docutils literal notranslate"><span class="pre">Affine.linear_inverse()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Affine.normalize"><code class="docutils literal notranslate"><span class="pre">Affine.normalize()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Affine.squeeze"><code class="docutils literal notranslate"><span class="pre">Affine.squeeze()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Affine.to_homogeneous"><code class="docutils literal notranslate"><span class="pre">Affine.to_homogeneous()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#roma.transforms.Isometry"><code class="docutils literal notranslate"><span class="pre">Isometry</span></code></a><ul>
<li><a class="reference internal" href="#roma.transforms.Isometry.apply"><code class="docutils literal notranslate"><span class="pre">Isometry.apply()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Isometry.as_tuple"><code class="docutils literal notranslate"><span class="pre">Isometry.as_tuple()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Isometry.clone"><code class="docutils literal notranslate"><span class="pre">Isometry.clone()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Isometry.compose"><code class="docutils literal notranslate"><span class="pre">Isometry.compose()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Isometry.from_homogeneous"><code class="docutils literal notranslate"><span class="pre">Isometry.from_homogeneous()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Isometry.identity"><code class="docutils literal notranslate"><span class="pre">Isometry.identity()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Isometry.identity_like"><code class="docutils literal notranslate"><span class="pre">Isometry.identity_like()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Isometry.inverse"><code class="docutils literal notranslate"><span class="pre">Isometry.inverse()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Isometry.linear_apply"><code class="docutils literal notranslate"><span class="pre">Isometry.linear_apply()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Isometry.linear_compose"><code class="docutils literal notranslate"><span class="pre">Isometry.linear_compose()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Isometry.linear_inverse"><code class="docutils literal notranslate"><span class="pre">Isometry.linear_inverse()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Isometry.linear_normalize"><code class="docutils literal notranslate"><span class="pre">Isometry.linear_normalize()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Isometry.normalize"><code class="docutils literal notranslate"><span class="pre">Isometry.normalize()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Isometry.squeeze"><code class="docutils literal notranslate"><span class="pre">Isometry.squeeze()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Isometry.to_homogeneous"><code class="docutils literal notranslate"><span class="pre">Isometry.to_homogeneous()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#roma.transforms.Linear"><code class="docutils literal notranslate"><span class="pre">Linear</span></code></a><ul>
<li><a class="reference internal" href="#roma.transforms.Linear.apply"><code class="docutils literal notranslate"><span class="pre">Linear.apply()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Linear.clone"><code class="docutils literal notranslate"><span class="pre">Linear.clone()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Linear.compose"><code class="docutils literal notranslate"><span class="pre">Linear.compose()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Linear.inverse"><code class="docutils literal notranslate"><span class="pre">Linear.inverse()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Linear.linear_apply"><code class="docutils literal notranslate"><span class="pre">Linear.linear_apply()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Linear.linear_compose"><code class="docutils literal notranslate"><span class="pre">Linear.linear_compose()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Linear.linear_inverse"><code class="docutils literal notranslate"><span class="pre">Linear.linear_inverse()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Linear.normalize"><code class="docutils literal notranslate"><span class="pre">Linear.normalize()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#roma.transforms.Orthonormal"><code class="docutils literal notranslate"><span class="pre">Orthonormal</span></code></a><ul>
<li><a class="reference internal" href="#roma.transforms.Orthonormal.apply"><code class="docutils literal notranslate"><span class="pre">Orthonormal.apply()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Orthonormal.clone"><code class="docutils literal notranslate"><span class="pre">Orthonormal.clone()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Orthonormal.compose"><code class="docutils literal notranslate"><span class="pre">Orthonormal.compose()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Orthonormal.inverse"><code class="docutils literal notranslate"><span class="pre">Orthonormal.inverse()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Orthonormal.linear_apply"><code class="docutils literal notranslate"><span class="pre">Orthonormal.linear_apply()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Orthonormal.linear_compose"><code class="docutils literal notranslate"><span class="pre">Orthonormal.linear_compose()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Orthonormal.linear_inverse"><code class="docutils literal notranslate"><span class="pre">Orthonormal.linear_inverse()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Orthonormal.linear_normalize"><code class="docutils literal notranslate"><span class="pre">Orthonormal.linear_normalize()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Orthonormal.normalize"><code class="docutils literal notranslate"><span class="pre">Orthonormal.normalize()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#roma.transforms.Rigid"><code class="docutils literal notranslate"><span class="pre">Rigid</span></code></a><ul>
<li><a class="reference internal" href="#roma.transforms.Rigid.apply"><code class="docutils literal notranslate"><span class="pre">Rigid.apply()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Rigid.as_tuple"><code class="docutils literal notranslate"><span class="pre">Rigid.as_tuple()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Rigid.clone"><code class="docutils literal notranslate"><span class="pre">Rigid.clone()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Rigid.compose"><code class="docutils literal notranslate"><span class="pre">Rigid.compose()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Rigid.from_homogeneous"><code class="docutils literal notranslate"><span class="pre">Rigid.from_homogeneous()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Rigid.identity"><code class="docutils literal notranslate"><span class="pre">Rigid.identity()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Rigid.identity_like"><code class="docutils literal notranslate"><span class="pre">Rigid.identity_like()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Rigid.inverse"><code class="docutils literal notranslate"><span class="pre">Rigid.inverse()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Rigid.linear_apply"><code class="docutils literal notranslate"><span class="pre">Rigid.linear_apply()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Rigid.linear_compose"><code class="docutils literal notranslate"><span class="pre">Rigid.linear_compose()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Rigid.linear_inverse"><code class="docutils literal notranslate"><span class="pre">Rigid.linear_inverse()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Rigid.linear_normalize"><code class="docutils literal notranslate"><span class="pre">Rigid.linear_normalize()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Rigid.normalize"><code class="docutils literal notranslate"><span class="pre">Rigid.normalize()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Rigid.squeeze"><code class="docutils literal notranslate"><span class="pre">Rigid.squeeze()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Rigid.to_homogeneous"><code class="docutils literal notranslate"><span class="pre">Rigid.to_homogeneous()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Rigid.to_rigidunitquat"><code class="docutils literal notranslate"><span class="pre">Rigid.to_rigidunitquat()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#roma.transforms.RigidUnitQuat"><code class="docutils literal notranslate"><span class="pre">RigidUnitQuat</span></code></a><ul>
<li><a class="reference internal" href="#roma.transforms.RigidUnitQuat.apply"><code class="docutils literal notranslate"><span class="pre">RigidUnitQuat.apply()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.RigidUnitQuat.as_tuple"><code class="docutils literal notranslate"><span class="pre">RigidUnitQuat.as_tuple()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.RigidUnitQuat.clone"><code class="docutils literal notranslate"><span class="pre">RigidUnitQuat.clone()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.RigidUnitQuat.compose"><code class="docutils literal notranslate"><span class="pre">RigidUnitQuat.compose()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.RigidUnitQuat.from_homogeneous"><code class="docutils literal notranslate"><span class="pre">RigidUnitQuat.from_homogeneous()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.RigidUnitQuat.inverse"><code class="docutils literal notranslate"><span class="pre">RigidUnitQuat.inverse()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.RigidUnitQuat.linear_apply"><code class="docutils literal notranslate"><span class="pre">RigidUnitQuat.linear_apply()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.RigidUnitQuat.linear_compose"><code class="docutils literal notranslate"><span class="pre">RigidUnitQuat.linear_compose()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.RigidUnitQuat.linear_inverse"><code class="docutils literal notranslate"><span class="pre">RigidUnitQuat.linear_inverse()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.RigidUnitQuat.linear_normalize"><code class="docutils literal notranslate"><span class="pre">RigidUnitQuat.linear_normalize()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.RigidUnitQuat.normalize"><code class="docutils literal notranslate"><span class="pre">RigidUnitQuat.normalize()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.RigidUnitQuat.squeeze"><code class="docutils literal notranslate"><span class="pre">RigidUnitQuat.squeeze()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.RigidUnitQuat.to_homogeneous"><code class="docutils literal notranslate"><span class="pre">RigidUnitQuat.to_homogeneous()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.RigidUnitQuat.to_rigid"><code class="docutils literal notranslate"><span class="pre">RigidUnitQuat.to_rigid()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#roma.transforms.Rotation"><code class="docutils literal notranslate"><span class="pre">Rotation</span></code></a><ul>
<li><a class="reference internal" href="#roma.transforms.Rotation.apply"><code class="docutils literal notranslate"><span class="pre">Rotation.apply()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Rotation.clone"><code class="docutils literal notranslate"><span class="pre">Rotation.clone()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Rotation.compose"><code class="docutils literal notranslate"><span class="pre">Rotation.compose()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Rotation.inverse"><code class="docutils literal notranslate"><span class="pre">Rotation.inverse()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Rotation.linear_apply"><code class="docutils literal notranslate"><span class="pre">Rotation.linear_apply()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Rotation.linear_compose"><code class="docutils literal notranslate"><span class="pre">Rotation.linear_compose()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Rotation.linear_inverse"><code class="docutils literal notranslate"><span class="pre">Rotation.linear_inverse()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Rotation.linear_normalize"><code class="docutils literal notranslate"><span class="pre">Rotation.linear_normalize()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.Rotation.normalize"><code class="docutils literal notranslate"><span class="pre">Rotation.normalize()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#roma.transforms.RotationUnitQuat"><code class="docutils literal notranslate"><span class="pre">RotationUnitQuat</span></code></a><ul>
<li><a class="reference internal" href="#roma.transforms.RotationUnitQuat.apply"><code class="docutils literal notranslate"><span class="pre">RotationUnitQuat.apply()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.RotationUnitQuat.clone"><code class="docutils literal notranslate"><span class="pre">RotationUnitQuat.clone()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.RotationUnitQuat.compose"><code class="docutils literal notranslate"><span class="pre">RotationUnitQuat.compose()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.RotationUnitQuat.inverse"><code class="docutils literal notranslate"><span class="pre">RotationUnitQuat.inverse()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.RotationUnitQuat.linear_apply"><code class="docutils literal notranslate"><span class="pre">RotationUnitQuat.linear_apply()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.RotationUnitQuat.linear_compose"><code class="docutils literal notranslate"><span class="pre">RotationUnitQuat.linear_compose()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.RotationUnitQuat.linear_inverse"><code class="docutils literal notranslate"><span class="pre">RotationUnitQuat.linear_inverse()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.RotationUnitQuat.linear_normalize"><code class="docutils literal notranslate"><span class="pre">RotationUnitQuat.linear_normalize()</span></code></a></li>
<li><a class="reference internal" href="#roma.transforms.RotationUnitQuat.normalize"><code class="docutils literal notranslate"><span class="pre">RotationUnitQuat.normalize()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#advanced">Advanced</a><ul>
<li><a class="reference internal" href="#running-unit-tests">Running unit tests</a></li>
<li><a class="reference internal" href="#building-sphinx-documentation">Building Sphinx documentation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#license">License</a></li>
<li><a class="reference internal" href="#changelog">Changelog</a></li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">RoMa</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">RoMa: A lightweight library to deal with 3D rotations in PyTorch.</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="roma-a-lightweight-library-to-deal-with-3d-rotations-in-pytorch">
<h1><a class="toc-backref" href="#id4" role="doc-backlink">RoMa: A lightweight library to deal with 3D rotations in PyTorch.</a><a class="headerlink" href="#roma-a-lightweight-library-to-deal-with-3d-rotations-in-pytorch" title="Link to this heading"></a></h1>
<p><em>RoMa</em> (which stands for <em>Rotation Manipulation</em>) provides differentiable mappings between 3D rotation representations, mappings from Euclidean to rotation space, and various utilities related to rotations.
It is implemented in PyTorch and aims to be an easy-to-use and reasonably efficient toolbox for Machine Learning and gradient-based optimization.</p>
<a class="reference internal image-reference" href="_images/roma_logo.png"><img alt="RoMa logo" class="align-center" src="_images/roma_logo.png" style="width: 200px;" />
</a>
<p>For a more comprehensive discussion on differentiable mappings in the 3D rotation space, see:</p>
<blockquote>
<div><p><strong>Romain Brégier, Deep Regression on Manifolds: A 3D Rotation Case Study.</strong> in 2021 International Conference on 3D Vision (3DV), 2021. (<a class="reference external" href="https://arxiv.org/abs/2103.16317">https://arxiv.org/abs/2103.16317</a>).</p>
</div></blockquote>
<p>Please cite this work if you use <em>RoMa</em> for your research:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@inproceedings</span><span class="p">{</span><span class="n">bregier2021deepregression</span><span class="p">,</span>
    <span class="n">title</span><span class="o">=</span><span class="p">{</span><span class="n">Deep</span> <span class="n">Regression</span> <span class="n">on</span> <span class="n">Manifolds</span><span class="p">:</span> <span class="n">a</span> <span class="p">{</span><span class="mi">3</span><span class="n">D</span><span class="p">}</span> <span class="n">Rotation</span> <span class="n">Case</span> <span class="n">Study</span><span class="p">},</span>
    <span class="n">author</span><span class="o">=</span><span class="p">{</span><span class="n">Br</span><span class="p">{</span>\<span class="s1">&#39;e}gier, Romain},</span>
    <span class="n">journal</span><span class="o">=</span><span class="p">{</span><span class="mi">2021</span> <span class="n">International</span> <span class="n">Conference</span> <span class="n">on</span> <span class="mi">3</span><span class="n">D</span> <span class="n">Vision</span> <span class="p">(</span><span class="mi">3</span><span class="n">DV</span><span class="p">)},</span>
    <span class="n">year</span><span class="o">=</span><span class="p">{</span><span class="mi">2021</span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="installation">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">Installation</a><a class="headerlink" href="#installation" title="Link to this heading"></a></h2>
<p>The easiest way to install <em>RoMa</em> is to use pip:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="n">roma</span>
</pre></div>
</div>
<p>Alternatively one can install the latest version of <em>RoMa</em> directly from the source repository:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="n">git</span><span class="o">+</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">naver</span><span class="o">/</span><span class="n">roma</span>
</pre></div>
</div>
<p><strong>With old pytorch versions (torch&lt;1.8)</strong>, we recommend installing <a class="reference external" href="https://github.com/KinglittleQ/torch-batch-svd">torch-batch-svd</a>
to achieve a significant speed-up with <a class="reference internal" href="#roma.mappings.procrustes" title="roma.mappings.procrustes"><code class="xref py py-func docutils literal notranslate"><span class="pre">procrustes()</span></code></a> on CUDA GPUs (see section <a class="reference internal" href="#why-a-new-library"><span class="std std-ref">Why a new library?</span></a>).
You can check that this module is properly loaded using the function <a class="reference internal" href="#roma.utils.is_torch_batch_svd_available" title="roma.utils.is_torch_batch_svd_available"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_torch_batch_svd_available()</span></code></a>.
<strong>With recent pytorch installations (torch&gt;=1.8), torch-batch-svd is no longer needed or used.</strong></p>
<nav class="contents" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#roma-a-lightweight-library-to-deal-with-3d-rotations-in-pytorch" id="id4">RoMa: A lightweight library to deal with 3D rotations in PyTorch.</a></p>
<ul>
<li><p><a class="reference internal" href="#installation" id="id5">Installation</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#main-features" id="id6">Main features</a></p>
<ul>
<li><p><a class="reference internal" href="#supported-rotation-representations" id="id7">Supported rotation representations</a></p></li>
<li><p><a class="reference internal" href="#mappings-between-rotation-representations" id="id8">Mappings between rotation representations</a></p></li>
<li><p><a class="reference internal" href="#mappings-from-euclidean-to-3d-rotation-space" id="id9">Mappings from Euclidean to 3D rotation space</a></p></li>
<li><p><a class="reference internal" href="#support-for-an-arbitrary-number-of-batch-dimensions" id="id10">Support for an arbitrary number of batch dimensions</a></p></li>
<li><p><a class="reference internal" href="#quaternion-operations" id="id11">Quaternion operations</a></p></li>
<li><p><a class="reference internal" href="#rotation-composition-and-inverse" id="id12">Rotation composition and inverse</a></p></li>
<li><p><a class="reference internal" href="#rotation-metrics" id="id13">Rotation metrics</a></p></li>
<li><p><a class="reference internal" href="#weighted-rotation-averaging" id="id14">Weighted rotation averaging</a></p></li>
<li><p><a class="reference internal" href="#rigid-registration" id="id15">Rigid registration</a></p></li>
<li><p><a class="reference internal" href="#spherical-linear-interpolation-slerp" id="id16">Spherical linear interpolation (SLERP)</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#why-a-new-library" id="id17">Why a new library?</a></p></li>
<li><p><a class="reference internal" href="#api-documentation" id="id18">API Documentation</a></p>
<ul>
<li><p><a class="reference internal" href="#module-roma.mappings" id="id19">Mappings</a></p></li>
<li><p><a class="reference internal" href="#module-roma.utils" id="id20">Utils</a></p></li>
<li><p><a class="reference internal" href="#module-roma.transforms" id="id21">Spatial transformations</a></p>
<ul>
<li><p><a class="reference internal" href="#example-of-use" id="id22">Example of use</a></p></li>
<li><p><a class="reference internal" href="#applying-a-transformation" id="id23">Applying a transformation</a></p></li>
<li><p><a class="reference internal" href="#aliasing-issues" id="id24">Aliasing issues</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#advanced" id="id25">Advanced</a></p>
<ul>
<li><p><a class="reference internal" href="#running-unit-tests" id="id26">Running unit tests</a></p></li>
<li><p><a class="reference internal" href="#building-sphinx-documentation" id="id27">Building Sphinx documentation</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#license" id="id28">License</a></p></li>
<li><p><a class="reference internal" href="#changelog" id="id29">Changelog</a></p></li>
</ul>
</nav>
</section>
</section>
<section id="main-features">
<h1><a class="toc-backref" href="#id6" role="doc-backlink">Main features</a><a class="headerlink" href="#main-features" title="Link to this heading"></a></h1>
<section id="supported-rotation-representations">
<h2><a class="toc-backref" href="#id7" role="doc-backlink">Supported rotation representations</a><a class="headerlink" href="#supported-rotation-representations" title="Link to this heading"></a></h2>
<dl>
<dt>Rotation vector (rotvec)</dt><dd><ul class="simple">
<li><p>Encoded using a …x3 tensor.</p></li>
<li><p>3D vector <em>angle</em> * <em>axis</em> represents a rotation of angle <em>angle</em> (expressed in radians) around a unit 3D <em>axis</em>.</p></li>
</ul>
</dd>
<dt>Unit quaternion (unitquat)</dt><dd><ul class="simple">
<li><p>Encoded as …x4 tensor.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>We use XYZW quaternion convention, <em>i.e.</em> components of quaternion <span class="math notranslate nohighlight">\(x i + y j + z k + w\)</span>
are represented by the 4D vector <span class="math notranslate nohighlight">\((x,y,z,w)\)</span>.</p></li>
<li><p>We assume unit quaternions to be of unit length, and do not perform implicit normalization.</p></li>
</ul>
</div>
</dd>
<dt>Rotation matrix (rotmat)</dt><dd><ul class="simple">
<li><p>Encoded as a …xDxD tensor (D=3 for 3D rotations).</p></li>
<li><p>We use column-vector convention, i.e. <span class="math notranslate nohighlight">\(R X\)</span> is the transformation of a 1xD vector <span class="math notranslate nohighlight">\(X\)</span>  by a rotation matrix <span class="math notranslate nohighlight">\(R\)</span>.</p></li>
</ul>
</dd>
<dt>Euler angles and Tait-Bryan angles (euler)</dt><dd><ul class="simple">
<li><p>Encoded as a …xD tensor or a list of D tensors corresponding to each angle (D=3 for typical Euler angles conventions).</p></li>
<li><p>We provide mappings between Euler angles and other rotation representations. Euler angles suffer from shortcomings such as gimbal lock, and we recommend using quaternions or rotation matrices to perform actual computations.</p></li>
</ul>
</dd>
</dl>
</section>
<section id="mappings-between-rotation-representations">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">Mappings between rotation representations</a><a class="headerlink" href="#mappings-between-rotation-representations" title="Link to this heading"></a></h2>
<p><em>RoMa</em> provides functions to convert between rotation representations.</p>
<p>Example mapping a batch of rotation vectors into corresponding unit quaternions:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span><span class="o">,</span><span class="w"> </span><span class="nn">roma</span>
<span class="n">batch_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">rotvec</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">,))</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">rotvec_to_unitquat</span><span class="p">(</span><span class="n">rotvec</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="mappings-from-euclidean-to-3d-rotation-space">
<h2><a class="toc-backref" href="#id9" role="doc-backlink">Mappings from Euclidean to 3D rotation space</a><a class="headerlink" href="#mappings-from-euclidean-to-3d-rotation-space" title="Link to this heading"></a></h2>
<p>Mapping an arbitrary tensor to a valid rotation can be useful <em>e.g.</em> for Machine Learning applications.
While rotation vectors or Euler angles can be used for such purpose, they suffer from various shortcomings, and we therefore provide the following alternative mappings:</p>
<dl class="simple">
<dt><a class="reference internal" href="#roma.mappings.special_gramschmidt" title="roma.mappings.special_gramschmidt"><code class="xref py py-func docutils literal notranslate"><span class="pre">special_gramschmidt()</span></code></a></dt><dd><p>Mapping from a 3x2 tensor to 3x3 rotation matrix, using special Gram-Schmidt orthonormalization (<em>6D</em> representation, popularized by <a class="reference external" href="https://arxiv.org/abs/1812.07035">Zhou et al.</a>).</p>
</dd>
<dt><a class="reference internal" href="#roma.mappings.special_procrustes" title="roma.mappings.special_procrustes"><code class="xref py py-func docutils literal notranslate"><span class="pre">special_procrustes()</span></code></a></dt><dd><p>Mapping from a nxn arbitrary matrix to a nxn rotation matrix, using special orthogonal Procrustes orthonormalization.</p>
</dd>
<dt><a class="reference internal" href="#roma.mappings.symmatrixvec_to_unitquat" title="roma.mappings.symmatrixvec_to_unitquat"><code class="xref py py-func docutils literal notranslate"><span class="pre">symmatrixvec_to_unitquat()</span></code></a></dt><dd><p>Mapping from a 10D vector to an antipodal pair of quaternion through eigenvector decomposition of a 4x4 symmetric matrix, proposed by <a class="reference external" href="https://arxiv.org/abs/2006.01031">Peretroukhin et al.</a>.</p>
</dd>
</dl>
<p>For general purpose applications, we recommend the use of <a class="reference internal" href="#roma.mappings.special_procrustes" title="roma.mappings.special_procrustes"><code class="xref py py-func docutils literal notranslate"><span class="pre">special_procrustes()</span></code></a> which projects an arbitrary square matrix onto the closest matrix of the rotation space,
considering Frobenius norm. Please refer to this <a class="reference external" href="https://arxiv.org/abs/2103.16317">paper</a> for more insights.</p>
<p>Example mapping random 3x3 matrices to valid rotation matrices:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span><span class="o">,</span><span class="w"> </span><span class="nn">roma</span>
<span class="n">batch_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,)</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">special_procrustes</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">roma</span><span class="o">.</span><span class="n">is_rotation_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="support-for-an-arbitrary-number-of-batch-dimensions">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">Support for an arbitrary number of batch dimensions</a><a class="headerlink" href="#support-for-an-arbitrary-number-of-batch-dimensions" title="Link to this heading"></a></h2>
<p>For convenience, functions accept an arbitrary number of batch dimensions:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span><span class="o">,</span><span class="w"> </span><span class="nn">roma</span>
<span class="nb">print</span><span class="p">(</span><span class="n">roma</span><span class="o">.</span><span class="n">rotvec_to_rotmat</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># -&gt; torch.Size([3, 3])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">roma</span><span class="o">.</span><span class="n">rotvec_to_rotmat</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># -&gt; torch.Size([5, 3, 3])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">roma</span><span class="o">.</span><span class="n">rotvec_to_rotmat</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># -&gt; torch.Size([2, 5, 3, 3])</span>
</pre></div>
</div>
</section>
<section id="quaternion-operations">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">Quaternion operations</a><a class="headerlink" href="#quaternion-operations" title="Link to this heading"></a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span><span class="o">,</span><span class="w"> </span><span class="nn">roma</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># Random unnormalized quaternion</span>
<span class="n">qconv</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">quat_conjugation</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="c1"># Quaternion conjugation</span>
<span class="n">qinv</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">quat_inverse</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="c1"># Quaternion inverse</span>
<span class="nb">print</span><span class="p">(</span><span class="n">roma</span><span class="o">.</span><span class="n">quat_product</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">qinv</span><span class="p">))</span> <span class="c1"># -&gt; [0,0,0,1] identity quaternion</span>
</pre></div>
</div>
</section>
<section id="rotation-composition-and-inverse">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">Rotation composition and inverse</a><a class="headerlink" href="#rotation-composition-and-inverse" title="Link to this heading"></a></h2>
<p>Example using rotation vector representation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span><span class="o">,</span><span class="w"> </span><span class="nn">roma</span>
<span class="n">rotvecs</span> <span class="o">=</span> <span class="p">[</span><span class="n">roma</span><span class="o">.</span><span class="n">random_rotvec</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span> <span class="c1"># Random rotation vectors</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">rotvec_composition</span><span class="p">(</span><span class="n">rotvecs</span><span class="p">)</span> <span class="c1"># Composition of an arbitrary number of rotations</span>
<span class="n">rinv</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">rotvec_inverse</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="c1"># Rotation vector corresponding to the inverse rotation</span>
</pre></div>
</div>
</section>
<section id="rotation-metrics">
<h2><a class="toc-backref" href="#id13" role="doc-backlink">Rotation metrics</a><a class="headerlink" href="#rotation-metrics" title="Link to this heading"></a></h2>
<p><em>RoMa</em> implements some usual similarity measures over the 3D rotation space:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span><span class="o">,</span><span class="w"> </span><span class="nn">roma</span>
<span class="n">R1</span><span class="p">,</span> <span class="n">R2</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">random_rotmat</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span> <span class="n">roma</span><span class="o">.</span><span class="n">random_rotmat</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">rotmat_geodesic_distance</span><span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="p">)</span> <span class="c1"># In radian</span>
<span class="n">cos_theta</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">rotmat_cosine_angle</span><span class="p">(</span><span class="n">R1</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">@</span> <span class="n">R2</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="weighted-rotation-averaging">
<h2><a class="toc-backref" href="#id14" role="doc-backlink">Weighted rotation averaging</a><a class="headerlink" href="#weighted-rotation-averaging" title="Link to this heading"></a></h2>
<p><a class="reference internal" href="#roma.mappings.special_procrustes" title="roma.mappings.special_procrustes"><code class="xref py py-func docutils literal notranslate"><span class="pre">special_procrustes()</span></code></a> can be used to easily average rotations:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span><span class="o">,</span><span class="w"> </span><span class="nn">roma</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">R_i</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">random_rotmat</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="c1"># Batch of n 3x3 rotation matrices to average</span>
<span class="n">w_i</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="c1"># Weight of each matrix, between 0 and 1</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w_i</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">R_i</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># 3x3 matrix</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">special_procrustes</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="c1"># weighted average.</span>
</pre></div>
</div>
<p>To be precise, it consists in the Fréchet mean considering the chordal distance.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The same average could be performed using quaternion representation and <em>symmatrix</em> mapping (slower batched implementation on GPU).</p>
</div>
</section>
<section id="rigid-registration">
<h2><a class="toc-backref" href="#id15" role="doc-backlink">Rigid registration</a><a class="headerlink" href="#rigid-registration" title="Link to this heading"></a></h2>
<p><a class="reference internal" href="#roma.utils.rigid_points_registration" title="roma.utils.rigid_points_registration"><code class="xref py py-func docutils literal notranslate"><span class="pre">rigid_points_registration()</span></code></a> and <a class="reference internal" href="#roma.utils.rigid_vectors_registration" title="roma.utils.rigid_vectors_registration"><code class="xref py py-func docutils literal notranslate"><span class="pre">rigid_vectors_registration()</span></code></a> enable to align ordered sets of points/vectors:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span><span class="o">,</span><span class="w"> </span><span class="nn">roma</span>
<span class="n">R_gt</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">random_rotmat</span><span class="p">()</span>
<span class="n">t_gt</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">src</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># source points / vectors</span>
<span class="n">target</span> <span class="o">=</span> <span class="n">src</span> <span class="o">@</span> <span class="n">R_gt</span><span class="o">.</span><span class="n">T</span> <span class="c1"># target vectors</span>
<span class="n">R_predicted</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">rigid_vectors_registration</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;R_gt</span><span class="se">\n</span><span class="si">{</span><span class="n">R_gt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;R_predicted</span><span class="se">\n</span><span class="si">{</span><span class="n">R_predicted</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">target</span> <span class="o">=</span> <span class="n">src</span> <span class="o">@</span> <span class="n">R_gt</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">t_gt</span> <span class="c1"># target points</span>
<span class="n">R_predicted</span><span class="p">,</span> <span class="n">t_predicted</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">rigid_points_registration</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;R_gt</span><span class="se">\n</span><span class="si">{</span><span class="n">R_gt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;R_predicted</span><span class="se">\n</span><span class="si">{</span><span class="n">R_predicted</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;t_gt</span><span class="se">\n</span><span class="si">{</span><span class="n">t_gt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;t_predicted</span><span class="se">\n</span><span class="si">{</span><span class="n">t_predicted</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="spherical-linear-interpolation-slerp">
<h2><a class="toc-backref" href="#id16" role="doc-backlink">Spherical linear interpolation (SLERP)</a><a class="headerlink" href="#spherical-linear-interpolation-slerp" title="Link to this heading"></a></h2>
<p>SLERP between batches of unit quaternions:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span><span class="o">,</span><span class="w"> </span><span class="nn">roma</span>
<span class="n">q0</span><span class="p">,</span> <span class="n">q1</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">random_unitquat</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">),</span> <span class="n">roma</span><span class="o">.</span><span class="n">random_unitquat</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">steps</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">q_interpolated</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">unitquat_slerp</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span> <span class="n">q1</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>
<span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># Print interpolations for an arbitrary element of the batch</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;q0:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">q0</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;q1:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">q1</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;q_interpolated:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">q_interpolated</span><span class="p">[:,</span><span class="n">idx</span><span class="p">])</span>
</pre></div>
</div>
<p>SLERP between rotation vectors (shortest path interpolation):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span><span class="o">,</span><span class="w"> </span><span class="nn">roma</span>
<span class="n">steps</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">rotvec0</span><span class="p">,</span> <span class="n">rotvec1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">rotvec_interpolated</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">rotvec_slerp</span><span class="p">(</span><span class="n">rotvec0</span><span class="p">,</span> <span class="n">rotvec1</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="why-a-new-library">
<h1><a class="toc-backref" href="#id17" role="doc-backlink">Why a new library?</a><a class="headerlink" href="#why-a-new-library" title="Link to this heading"></a></h1>
<dl>
<dt>We could not find a PyTorch library satisfying our needs, so we built our own.</dt><dd><p>We wanted a reliable, easy-to-use and efficient toolbox to deal with rotation representations in PyTorch.
While Kornia provides some utility functions to deal with 3D rotations, it included several major bugs at the time of writting (early 2021) (see e.g. <a class="reference external" href="https://github.com/kornia/kornia/issues/723">https://github.com/kornia/kornia/issues/723</a> or <a class="reference external" href="https://github.com/kornia/kornia/issues/317">https://github.com/kornia/kornia/issues/317</a>).</p>
</dd>
<dt>Care for numerical precision</dt><dd><p><em>RoMa</em> is implemented with numerical precision in mind, e.g. with a special handling of small angle rotation vectors
or through the choice of appropriate algorithms.</p>
<p>As an example, below is plotted a function that takes as input an angle <span class="math notranslate nohighlight">\(\theta\)</span>,
produces a rotation matrix <span class="math notranslate nohighlight">\(R_z(\theta)\)</span> of angle <span class="math notranslate nohighlight">\(\theta\)</span> and estimates its geodesic distance with respect to the identity matrix, using 32 bits floating point arithmetic.
We observe that <a class="reference internal" href="#roma.utils.rotmat_geodesic_distance" title="roma.utils.rotmat_geodesic_distance"><code class="xref py py-func docutils literal notranslate"><span class="pre">rotmat_geodesic_distance()</span></code></a> is much more precise for this task than an other implementation
often found in academic code: <a class="reference internal" href="#roma.utils.rotmat_geodesic_distance_naive" title="roma.utils.rotmat_geodesic_distance_naive"><code class="xref py py-func docutils literal notranslate"><span class="pre">rotmat_geodesic_distance_naive()</span></code></a>.
Backward pass through <a class="reference internal" href="#roma.utils.rotmat_geodesic_distance_naive" title="roma.utils.rotmat_geodesic_distance_naive"><code class="xref py py-func docutils literal notranslate"><span class="pre">rotmat_geodesic_distance_naive()</span></code></a> leads to unstable gradient estimations and produces <em>Not-a-Number</em> values for small angles,
whereas <a class="reference internal" href="#roma.utils.rotmat_geodesic_distance_naive" title="roma.utils.rotmat_geodesic_distance_naive"><code class="xref py py-func docutils literal notranslate"><span class="pre">rotmat_geodesic_distance_naive()</span></code></a> is well-behaved, and returns <em>Not-a-Number</em> only for 0.0 angle where gradient is mathematically undefined.</p>
<img alt="_images/rotmat_geodesic_distance_zero.svg" src="_images/rotmat_geodesic_distance_zero.svg" />
<img alt="_images/rotmat_geodesic_distance_grads_zero.svg" src="_images/rotmat_geodesic_distance_grads_zero.svg" />
</dd>
<dt>Computation efficiency</dt><dd><p><em>RoMa</em> favors code clarity, but aims to be reasonably efficient.</p>
<p>In particular, for Procrustes orthonormalization it can use on NVidia GPUs a batched SVD decomposition
that provides orders of magnitude speed-ups for large batch sizes compared to vanilla <code class="docutils literal notranslate"><span class="pre">torch.svd()</span></code> for PyTorch versions below 1.8.
The plot below was obtained for random 3x3 matrices, with PyTorch 1.7, a NVidia Tesla T4 GPU and CUDA 11.0.
<em>Note that recent versions of pytorch (&gt;=1.8) integrate such speed up off-the-shelf.</em></p>
<img alt="_images/special_procrustes_benchmark.svg" src="_images/special_procrustes_benchmark.svg" />
</dd>
<dt>Syntactic sugar</dt><dd><p><em>RoMa</em> aims to be easy-to-use with a simple syntax, and support for an arbitrary number of batch dimensions to let users focus on their applications.</p>
</dd>
</dl>
</section>
<section id="api-documentation">
<h1><a class="toc-backref" href="#id18" role="doc-backlink">API Documentation</a><a class="headerlink" href="#api-documentation" title="Link to this heading"></a></h1>
<section id="module-roma.mappings">
<span id="mappings"></span><h2><a class="toc-backref" href="#id19" role="doc-backlink">Mappings</a><a class="headerlink" href="#module-roma.mappings" title="Link to this heading"></a></h2>
<p>Various mappings between different rotation representations.</p>
<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.procrustes">
<span class="sig-name descname"><span class="pre">procrustes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regularization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient_eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_singular_values</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.procrustes" title="Link to this definition"></a></dt>
<dd><p>Returns the orthonormal matrix <span class="math notranslate nohighlight">\(R\)</span> minimizing Frobenius norm <span class="math notranslate nohighlight">\(\| M - R \|_F\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>...</em><em>xNxN tensor</em>) – batch of square matrices.</p></li>
<li><p><strong>force_rotation</strong> (<em>bool</em>) – if True, forces the output to be a rotation matrix.</p></li>
<li><p><strong>regularization</strong> (<em>float &gt;= 0</em>) – weight of a regularization term added to the gradient.
Using this regularization is equivalent to adding a term <span class="math notranslate nohighlight">\(regularization * \| M - R \|_F^2\)</span> to the training loss function.</p></li>
<li><p><strong>gradient_eps</strong> (<em>float &gt; 0</em>) – small value used to enforce numerical stability during backpropagation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of orthonormal matrices (…xNxN tensor) and optional singular values.
For advanced users, singular values of the SVD decomposition with sign flipping (… tensor) can optionally be returned by setting the argument <code class="code docutils literal notranslate"><span class="pre">return_singular_values</span></code> to <code class="code docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.procrustes_naive">
<span class="sig-name descname"><span class="pre">procrustes_naive</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_rotation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_singular_values</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.procrustes_naive" title="Link to this definition"></a></dt>
<dd><p>Implementation of <a class="reference internal" href="#roma.mappings.procrustes" title="roma.mappings.procrustes"><code class="xref py py-func docutils literal notranslate"><span class="pre">procrustes()</span></code></a> relying on default backward pass of autograd and SVD decomposition.
Could be slightly less stable than <a class="reference internal" href="#roma.mappings.procrustes" title="roma.mappings.procrustes"><code class="xref py py-func docutils literal notranslate"><span class="pre">procrustes()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.quat_wxyz_to_xyzw">
<span class="sig-name descname"><span class="pre">quat_wxyz_to_xyzw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wxyz</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.quat_wxyz_to_xyzw" title="Link to this definition"></a></dt>
<dd><p>Convert quaternion from WXYZ to XYZW convention.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>wxyz</strong> (<em>...</em><em>x4 tensor</em><em>, </em><em>WXYZ convention</em>) – batch of quaternions.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of quaternions (…x4 tensor, XYZW convention).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.quat_xyzw_to_wxyz">
<span class="sig-name descname"><span class="pre">quat_xyzw_to_wxyz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyzw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.quat_xyzw_to_wxyz" title="Link to this definition"></a></dt>
<dd><p>Convert quaternion from XYZW to WXYZ convention.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xyzw</strong> (<em>...</em><em>x4 tensor</em><em>, </em><em>XYZW convention</em>) – batch of quaternions.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of quaternions (…x4 tensor, WXYZ convention).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.rotmat_to_rotvec">
<span class="sig-name descname"><span class="pre">rotmat_to_rotvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.rotmat_to_rotvec" title="Link to this definition"></a></dt>
<dd><p>Converts rotation matrix to rotation vector representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>R</strong> (<em>...</em><em>x3x3 tensor</em>) – batch of rotation matrices.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of rotation vectors (…x3 tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.rotmat_to_unitquat">
<span class="sig-name descname"><span class="pre">rotmat_to_unitquat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.rotmat_to_unitquat" title="Link to this definition"></a></dt>
<dd><p>Converts rotation matrix to unit quaternion representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>R</strong> (<em>...</em><em>x3x3 tensor</em>) – batch of rotation matrices.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of unit quaternions (…x4 tensor, XYZW convention).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.rotvec_to_rotmat">
<span class="sig-name descname"><span class="pre">rotvec_to_rotmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rotvec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Tensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tensor</span></span></span><a class="headerlink" href="#roma.mappings.rotvec_to_rotmat" title="Link to this definition"></a></dt>
<dd><p>Converts rotation vector to rotation matrix representation.
Conversion uses Rodrigues formula in general, and a first order approximation for small angles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rotvec</strong> (<em>...</em><em>x3 tensor</em>) – batch of rotation vectors.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – small angle threshold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of rotation matrices (…x3x3 tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.rotvec_to_unitquat">
<span class="sig-name descname"><span class="pre">rotvec_to_unitquat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rotvec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.rotvec_to_unitquat" title="Link to this definition"></a></dt>
<dd><p>Converts rotation vector into unit quaternion representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>rotvec</strong> (<em>...</em><em>x3 tensor</em>) – batch of rotation vectors.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of unit quaternions (…x4 tensor, XYZW convention).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.special_gramschmidt">
<span class="sig-name descname"><span class="pre">special_gramschmidt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.special_gramschmidt" title="Link to this definition"></a></dt>
<dd><p>Returns the 3x3 rotation matrix obtained by Gram-Schmidt orthonormalization of two 3D input vectors (first two columns of input matrix M).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>...</em><em>x3xN tensor</em>) – batch of 3xN matrices, with N &gt;= 2.
Only the first two columns of the matrices are used for orthonormalization.</p></li>
<li><p><strong>epsilon</strong> (<em>float &gt;= 0</em>) – optional clamping value to avoid returning <em>Not-a-Number</em> values in case of ill-defined input.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of rotation matrices (…x3x3 tensor).</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In case of ill-defined input (colinear input column vectors), the output will not be a rotation matrix.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.special_procrustes">
<span class="sig-name descname"><span class="pre">special_procrustes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regularization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient_eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_singular_values</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.special_procrustes" title="Link to this definition"></a></dt>
<dd><p>Returns the rotation matrix <span class="math notranslate nohighlight">\(R\)</span> minimizing Frobenius norm <span class="math notranslate nohighlight">\(\| M - R \|_F\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> (<em>...</em><em>xNxN tensor</em>) – batch of square matrices.</p></li>
<li><p><strong>regularization</strong> (<em>float &gt;= 0</em>) – weight of a regularization term added to the gradient.
Using this regularization is equivalent to adding a term <span class="math notranslate nohighlight">\(regularization * \| M - R \|_F^2\)</span> to the training loss function.</p></li>
<li><p><strong>gradient_eps</strong> (<em>float &gt; 0</em>) – small value used to enforce numerical stability during backpropagation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of rotation matrices (…xNxN tensor).
For advanced users, singular values of the SVD decomposition with sign flipping (… tensor) can optionally be returned by setting the argument <code class="code docutils literal notranslate"><span class="pre">return_singular_values</span></code> to <code class="code docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.special_procrustes_naive">
<span class="sig-name descname"><span class="pre">special_procrustes_naive</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_singular_values</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.special_procrustes_naive" title="Link to this definition"></a></dt>
<dd><p>Implementation of <a class="reference internal" href="#roma.mappings.special_procrustes" title="roma.mappings.special_procrustes"><code class="xref py py-func docutils literal notranslate"><span class="pre">special_procrustes()</span></code></a> relying on default backward pass of autograd and SVD decomposition.
Could be slightly less stable than <a class="reference internal" href="#roma.mappings.special_procrustes" title="roma.mappings.special_procrustes"><code class="xref py py-func docutils literal notranslate"><span class="pre">special_procrustes()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.symmatrix_to_projective_point">
<span class="sig-name descname"><span class="pre">symmatrix_to_projective_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.symmatrix_to_projective_point" title="Link to this definition"></a></dt>
<dd><p>Converts a DxD symmetric matrix A into a projective point represented by a unit vector <span class="math notranslate nohighlight">\(q\)</span> minimizing <span class="math notranslate nohighlight">\(q^T A q\)</span>.
Only the lower part of the matrix is considered in practice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>A</strong> (<em>...</em><em>xDxD tensor</em>) – batch of symmetric matrices. Only the lower triangular part is considered.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of unit vectors <span class="math notranslate nohighlight">\(q\)</span> (…xD tensor).</p>
</dd>
</dl>
<dl class="simple">
<dt>Reference:</dt><dd><ol class="upperalpha simple" start="22">
<li><p>Peretroukhin, M. Giamou, D. M. Rosen, W. N. Greene, N. Roy, and J. Kelly, “A Smooth Representation of Belief over SO(3) for Deep Rotation Learning with Uncertainty,” 2020, doi: 10.15607/RSS.2020.XVI.007.</p></li>
</ol>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<ul class="simple">
<li><p>This mapping is unstable when the smallest eigenvalue of A has a multiplicity strictly greater than 1.</p></li>
<li><p>The eigenvalue decomposition may fail, in particular when using single precision numbers.</p></li>
<li><p>Current implementation is rather slow due to the implementation of <code class="docutils literal notranslate"><span class="pre">torch.symeig</span></code>.
The CuSolver library provides a faster eigenvalue decomposition alternative, but results where found to be unreliable.</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.symmatrixvec_to_unitquat">
<span class="sig-name descname"><span class="pre">symmatrixvec_to_unitquat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.symmatrixvec_to_unitquat" title="Link to this definition"></a></dt>
<dd><p>Converts a 10D vector into a unit quaternion representation.
Based on <a class="reference internal" href="#roma.mappings.symmatrix_to_projective_point" title="roma.mappings.symmatrix_to_projective_point"><code class="xref py py-func docutils literal notranslate"><span class="pre">symmatrix_to_projective_point()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>...</em><em>x10 tensor</em>) – batch of 10D vectors.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of unit quaternions (…x4 tensor, XYZW convention).</p>
</dd>
</dl>
<dl class="simple">
<dt>Reference:</dt><dd><ol class="upperalpha simple" start="22">
<li><p>Peretroukhin, M. Giamou, D. M. Rosen, W. N. Greene, N. Roy, and J. Kelly, “A Smooth Representation of Belief over SO(3) for Deep Rotation Learning with Uncertainty,” 2020, doi: 10.15607/RSS.2020.XVI.007.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.unitquat_to_rotmat">
<span class="sig-name descname"><span class="pre">unitquat_to_rotmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.unitquat_to_rotmat" title="Link to this definition"></a></dt>
<dd><p>Converts unit quaternion into rotation matrix representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>quat</strong> (<em>...</em><em>x4 tensor</em><em>, </em><em>XYZW convention</em>) – batch of unit quaternions.
No normalization is applied before computation.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of rotation matrices (…x3x3 tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.mappings.unitquat_to_rotvec">
<span class="sig-name descname"><span class="pre">unitquat_to_rotvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shortest_arc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.mappings.unitquat_to_rotvec" title="Link to this definition"></a></dt>
<dd><p>Converts unit quaternion into rotation vector representation.</p>
<p>Based on the representation of a rotation of angle <span class="math notranslate nohighlight">\({\theta}\)</span> and unit axis <span class="math notranslate nohighlight">\((x,y,z)\)</span>
by the unit quaternions <span class="math notranslate nohighlight">\(\pm [\sin({\theta} / 2) (x i + y j + z k) + \cos({\theta} / 2)]\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>quat</strong> (<em>...</em><em>x4 tensor</em><em>, </em><em>XYZW convention</em>) – batch of unit quaternions.
No normalization is applied before computation.</p></li>
<li><p><strong>shortest_arc</strong> (<em>bool</em>) – if True, the function returns the smallest rotation vectors corresponding
to the input 3D rotations, i.e. rotation vectors with a norm smaller than <span class="math notranslate nohighlight">\(\pi\)</span>.
If False, the function may return rotation vectors of norm larger than <span class="math notranslate nohighlight">\(\pi\)</span>, depending on the sign of the input quaternions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of rotation vectors (…x3 tensor).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Behavior is undefined for inputs <code class="docutils literal notranslate"><span class="pre">quat=torch.as_tensor([0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0,</span> <span class="pre">-1.0])</span></code> and <code class="docutils literal notranslate"><span class="pre">shortest_arc=False</span></code>,
as any rotation vector of angle <span class="math notranslate nohighlight">\(2 \pi\)</span> could be a valid representation in such case.</p>
</div>
</dd></dl>

<dl class="py function" id="module-roma.euler">
<dt class="sig sig-object py" id="roma.euler.euler_to_rotmat">
<span class="sig-name descname"><span class="pre">euler_to_rotmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">convention</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.euler.euler_to_rotmat" title="Link to this definition"></a></dt>
<dd><p>Convert Euler angles to rotation matrix representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>convention</strong> (<em>string</em>) – ‘xyz’ for example. See <a class="reference internal" href="#roma.euler.euler_to_unitquat" title="roma.euler.euler_to_unitquat"><code class="xref py py-func docutils literal notranslate"><span class="pre">euler_to_unitquat()</span></code></a>.</p></li>
<li><p><strong>angles</strong> (<em>...</em><em>xD tensor</em><em>, or </em><em>tuple/list</em><em> of </em><em>D floats</em><em> or </em><em>...</em><em> tensors</em>) – a list of angles associated to each axis, expressed in radians by default.</p></li>
<li><p><strong>degrees</strong> (<em>bool</em>) – if True, input angles are assumed to be expressed in degrees.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a batch of rotation matrices (…x3x3 tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.euler.euler_to_rotvec">
<span class="sig-name descname"><span class="pre">euler_to_rotvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">convention</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.euler.euler_to_rotvec" title="Link to this definition"></a></dt>
<dd><p>Convert Euler angles to rotation vector representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>convention</strong> (<em>string</em>) – ‘xyz’ for example. See <a class="reference internal" href="#roma.euler.euler_to_unitquat" title="roma.euler.euler_to_unitquat"><code class="xref py py-func docutils literal notranslate"><span class="pre">euler_to_unitquat()</span></code></a>.</p></li>
<li><p><strong>angles</strong> (<em>...</em><em>xD tensor</em><em>, or </em><em>tuple/list</em><em> of </em><em>D floats</em><em> or </em><em>...</em><em> tensors</em>) – a list of angles associated to each axis, expressed in radians by default.</p></li>
<li><p><strong>degrees</strong> (<em>bool</em>) – if True, input angles are assumed to be expressed in degrees.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a batch of rotation vectors (…x3 tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.euler.euler_to_unitquat">
<span class="sig-name descname"><span class="pre">euler_to_unitquat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">convention</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.euler.euler_to_unitquat" title="Link to this definition"></a></dt>
<dd><p>Convert Euler angles to unit quaternion representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>convention</strong> (<em>string</em>) – string defining a sequence of D rotation axes (‘XYZ’ or ‘xzx’ for example).
The sequence of rotation is expressed either with respect to a global ‘extrinsic’ coordinate system (in which case axes are denoted in lowercase: ‘x’, ‘y’, or ‘z’),
or with respect to an ‘intrinsic’ coordinates system attached to the object under rotation (in which case axes are denoted in uppercase: ‘X’, ‘Y’, ‘Z’).
Intrinsic and extrinsic conventions cannot be mixed.</p></li>
<li><p><strong>angles</strong> (<em>...</em><em>xD tensor</em><em>, or </em><em>tuple/list</em><em> of </em><em>D floats</em><em> or </em><em>...</em><em> tensors</em>) – a list of angles associated to each axis, expressed in radians by default.</p></li>
<li><p><strong>degrees</strong> (<em>bool</em>) – if True, input angles are assumed to be expressed in degrees.</p></li>
<li><p><strong>normalize</strong> (<em>bool</em>) – if True, normalize the returned quaternion to compensate potential numerical.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A batch of unit quaternions (…x4 tensor, XYZW convention).</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Case is important: ‘xyz’ and ‘XYZ’ denote different conventions.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.euler.rotmat_to_euler">
<span class="sig-name descname"><span class="pre">rotmat_to_euler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">convention</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotmat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">as_tuple</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.euler.rotmat_to_euler" title="Link to this definition"></a></dt>
<dd><p>Convert rotation matrix to Euler angles representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>convention</strong> (<em>str</em>) – string of 3 characters belonging to {‘x’, ‘y’, ‘z’} for extrinsic rotations, or {‘X’, ‘Y’, ‘Z’} for intrinsic rotations.
Consecutive axes should not be identical.</p></li>
<li><p><strong>rotmat</strong> (<em>...</em><em>x3x3 tensor</em>) – input batch of rotation matrices.</p></li>
<li><p><strong>as_tuple</strong> (<em>boolean</em>) – if True, angles are not stacked but returned as a tuple of tensors.</p></li>
<li><p><strong>degrees</strong> (<em>bool</em>) – if True, angles are returned in degrees.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – a small value used to detect degenerate configurations.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A stacked …x3 tensor corresponding to Euler angles, expressed by default in radians.
In case of gimbal lock, the third angle is arbitrarily set to 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.euler.rotvec_to_euler">
<span class="sig-name descname"><span class="pre">rotvec_to_euler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">convention</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotvec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">as_tuple</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.euler.rotvec_to_euler" title="Link to this definition"></a></dt>
<dd><p>Convert rotation vector to Euler angles representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>convention</strong> (<em>str</em>) – string of 3 characters belonging to {‘x’, ‘y’, ‘z’} for extrinsic rotations, or {‘X’, ‘Y’, ‘Z’} for intrinsic rotations.
Consecutive axes should not be identical.</p></li>
<li><p><strong>rotvec</strong> (<em>...</em><em>x3 tensor</em>) – input batch of rotation vectors.</p></li>
<li><p><strong>as_tuple</strong> (<em>boolean</em>) – if True, angles are not stacked but returned as a tuple of tensors.</p></li>
<li><p><strong>degrees</strong> (<em>bool</em>) – if True, angles are returned in degrees.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – a small value used to detect degenerate configurations.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A stacked …x3 tensor corresponding to Euler angles, expressed by default in radians.
In case of gimbal lock, the third angle is arbitrarily set to 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.euler.unitquat_to_euler">
<span class="sig-name descname"><span class="pre">unitquat_to_euler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">convention</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">as_tuple</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.euler.unitquat_to_euler" title="Link to this definition"></a></dt>
<dd><p>Convert unit quaternion to Euler angles representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>convention</strong> (<em>str</em>) – string of 3 characters belonging to {‘x’, ‘y’, ‘z’} for extrinsic rotations, or {‘X’, ‘Y’, ‘Z’} for intrinsic rotations.
Consecutive axes should not be identical.</p></li>
<li><p><strong>quat</strong> (<em>...</em><em>x4 tensor</em><em>, </em><em>XYZW convention</em>) – input batch of unit quaternion.</p></li>
<li><p><strong>as_tuple</strong> (<em>boolean</em>) – if True, angles are not stacked but returned as a tuple of tensors.</p></li>
<li><p><strong>degrees</strong> (<em>bool</em>) – if True, angles are returned in degrees.</p></li>
<li><p><strong>epsilon</strong> (<em>float</em>) – a small value used to detect degenerate configurations.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A stacked …x3 tensor corresponding to Euler angles, expressed by default in radians.
In case of gimbal lock, the third angle is arbitrarily set to 0.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-roma.utils">
<span id="utils"></span><h2><a class="toc-backref" href="#id20" role="doc-backlink">Utils</a><a class="headerlink" href="#module-roma.utils" title="Link to this heading"></a></h2>
<p>Various utility functions related to rotation representations.</p>
<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.identity_quat">
<span class="sig-name descname"><span class="pre">identity_quat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">torch.float32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.identity_quat" title="Link to this definition"></a></dt>
<dd><p>Return a batch of identity unit quaternions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>size</strong> (<em>tuple</em><em> or </em><em>int</em>) – batch size. Use for example <code class="docutils literal notranslate"><span class="pre">tuple()</span></code> to generate a single element, and <code class="docutils literal notranslate"><span class="pre">(5,2)</span></code> to generate a 5x2 batch.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of identity quaternions (size x 4 tensor, XYZW convention).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All returned batch quaternions refer to the same memory location.
Consider cloning the output tensor prior performing any in-place operations.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.is_orthonormal_matrix">
<span class="sig-name descname"><span class="pre">is_orthonormal_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.is_orthonormal_matrix" title="Link to this definition"></a></dt>
<dd><p>Test if matrices are orthonormal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>...</em><em>xDxD tensor</em>) – batch of square matrices.</p></li>
<li><p><strong>epsilon</strong> – tolerance threshold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>boolean tensor (shape …).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.is_rotation_matrix">
<span class="sig-name descname"><span class="pre">is_rotation_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.is_rotation_matrix" title="Link to this definition"></a></dt>
<dd><p>Test if matrices are rotation matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<em>...</em><em>xDxD tensor</em>) – batch of square matrices.</p></li>
<li><p><strong>epsilon</strong> – tolerance threshold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>boolean tensor (shape …).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.is_torch_batch_svd_available">
<span class="sig-name descname"><span class="pre">is_torch_batch_svd_available</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#roma.utils.is_torch_batch_svd_available" title="Link to this definition"></a></dt>
<dd><p>Returns True if the module ‘torch_batch_svd’ has been loaded. Returns False otherwise.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.quat_action">
<span class="sig-name descname"><span class="pre">quat_action</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.quat_action" title="Link to this definition"></a></dt>
<dd><p>Rotate a 3D vector <span class="math notranslate nohighlight">\(v=(x,y,z)\)</span> by a rotation represented by a quaternion <cite>q</cite>.</p>
<p>Based on the action by conjugation <span class="math notranslate nohighlight">\(q,v : q v q^{-1}\)</span>, considering the pure quaternion <span class="math notranslate nohighlight">\(v=xi + yj +zk\)</span> by abuse of notation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q</strong> (<em>...</em><em>x4 tensor</em><em>, </em><em>XYZW convention</em>) – batch of quaternions.</p></li>
<li><p><strong>v</strong> (<em>...</em><em>x3 tensor</em>) – batch of 3D vectors.</p></li>
<li><p><strong>is_normalized</strong> – use True if the input quaternions are already normalized, to avoid unnecessary computations.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of rotated 3D vectors (…x3 tensor).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>One should favor rotation matrix representation to rotate multiple vectors by the same rotation efficiently.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.quat_composition">
<span class="sig-name descname"><span class="pre">quat_composition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.quat_composition" title="Link to this definition"></a></dt>
<dd><p>Returns the product of a sequence of quaternions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sequence</strong> (<em>sequence</em><em> of </em><em>...</em><em>x4 tensors</em><em>, </em><em>XYZW convention</em>) – sequence of batches of quaternions.</p></li>
<li><p><strong>normalize</strong> (<em>bool</em>) – it True, normalize the returned quaternion.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of quaternions (…x4 tensor, XYZW convention).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.quat_conjugation">
<span class="sig-name descname"><span class="pre">quat_conjugation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.quat_conjugation" title="Link to this definition"></a></dt>
<dd><p>Returns the conjugation of input batch of quaternions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>quat</strong> (<em>...</em><em>x4 tensor</em><em>, </em><em>XYZW convention</em>) – batch of quaternions.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of quaternions (…x4 tensor, XYZW convention).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Conjugation of a unit quaternion is equal to its inverse.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.quat_inverse">
<span class="sig-name descname"><span class="pre">quat_inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.quat_inverse" title="Link to this definition"></a></dt>
<dd><p>Returns the inverse of a batch of quaternions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>quat</strong> (<em>...</em><em>x4 tensor</em><em>, </em><em>XYZW convention</em>) – batch of quaternions.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of quaternions (…x4 tensor, XYZW convention).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Inverse of null quaternion is undefined.</p></li>
<li><p>For unit quaternions, consider using conjugation instead.</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.quat_normalize">
<span class="sig-name descname"><span class="pre">quat_normalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.quat_normalize" title="Link to this definition"></a></dt>
<dd><p>Returns a normalized, unit norm, copy of a batch of quaternions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>quat</strong> (<em>...</em><em>x4 tensor</em><em>, </em><em>XYZW convention</em>) – batch of quaternions.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of quaternions (…x4 tensor, XYZW convention).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.quat_product">
<span class="sig-name descname"><span class="pre">quat_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.quat_product" title="Link to this definition"></a></dt>
<dd><p>Returns the product of two quaternions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> (<em>...</em><em>x4 tensor</em><em>, </em><em>XYZW convention</em>) – batch of quaternions.</p></li>
<li><p><strong>q</strong> (<em>...</em><em>x4 tensor</em><em>, </em><em>XYZW convention</em>) – batch of quaternions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of quaternions (…x4 tensor, XYZW convention).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.random_rotmat">
<span class="sig-name descname"><span class="pre">random_rotmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">torch.float32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.random_rotmat" title="Link to this definition"></a></dt>
<dd><p>Generates a batch of random 3x3 rotation matrices, uniformly sampled according to the usual rotation metric.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>size</strong> (<em>tuple</em><em> or </em><em>int</em>) – batch size. Use for example <code class="docutils literal notranslate"><span class="pre">tuple()</span></code> to generate a single element, and <code class="docutils literal notranslate"><span class="pre">(5,2)</span></code> to generate a 5x2 batch.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of rotation matrices (size x 3x3 tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.random_rotvec">
<span class="sig-name descname"><span class="pre">random_rotvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">torch.float32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.random_rotvec" title="Link to this definition"></a></dt>
<dd><p>Generates a batch of random rotation vectors, uniformly sampled according to the usual rotation metric.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>size</strong> (<em>tuple</em><em> or </em><em>int</em>) – batch size. Use for example <code class="docutils literal notranslate"><span class="pre">tuple()</span></code> to generate a single element, and <code class="docutils literal notranslate"><span class="pre">(5,2)</span></code> to generate a 5x2 batch.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of rotation vectors (size x 3 tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.random_unitquat">
<span class="sig-name descname"><span class="pre">random_unitquat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">torch.float32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.random_unitquat" title="Link to this definition"></a></dt>
<dd><p>Generates a batch of random unit quaternions, uniformly sampled according to the usual quaternion metric.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>size</strong> (<em>tuple</em><em> or </em><em>int</em>) – batch size. Use for example <code class="docutils literal notranslate"><span class="pre">tuple()</span></code> to generate a single element, and <code class="docutils literal notranslate"><span class="pre">(5,2)</span></code> to generate a 5x2 batch.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of unit quaternions (size x 4 tensor).</p>
</dd>
</dl>
<dl class="simple">
<dt>Reference:</dt><dd><ol class="upperalpha simple" start="11">
<li><p>Shoemake, “Uniform Random Rotations”, in Graphics Gems III (IBM Version), Elsevier, 1992, pp. 124–132. doi: 10.1016/B978-0-08-050755-2.50036-1.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.rigid_points_registration">
<span class="sig-name descname"><span class="pre">rigid_points_registration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.rigid_points_registration" title="Link to this definition"></a></dt>
<dd><p>Returns the rigid transformation <span class="math notranslate nohighlight">\((R,t)\)</span> and the optional scaling <span class="math notranslate nohighlight">\(s\)</span> that best align an input list of points <span class="math notranslate nohighlight">\((x_i)_{i=1...n}\)</span> to a target list of points <span class="math notranslate nohighlight">\((y_i)_{i=1...n}\)</span>,
by minimizing the sum of square distance <span class="math notranslate nohighlight">\(\sum_i w_i \|s R x_i + t - y_i\|^2\)</span>, where <span class="math notranslate nohighlight">\((w_i)_{i=1...n}\)</span> denotes optional positive weights.
This is sometimes referred to as the Kabsch/Umeyama algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>...</em><em>xNxD tensor</em>) – list of N points of dimension D.</p></li>
<li><p><strong>y</strong> (<em>...</em><em>xNxD tensor</em>) – list of corresponding target points.</p></li>
<li><p><strong>weights</strong> (<em>None</em><em> or </em><em>...</em><em>xN tensor</em>) – optional list of weights associated to each point.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a triplet <span class="math notranslate nohighlight">\((R, t, s)\)</span> consisting of a rotation matrix <span class="math notranslate nohighlight">\(R\)</span> (…xDxD tensor),
a translation vector <span class="math notranslate nohighlight">\(t\)</span> (…xD tensor),
and a scaling <span class="math notranslate nohighlight">\(s\)</span> (… tensor) if <code class="code docutils literal notranslate"><span class="pre">compute_scaling=True</span></code>.
Returns <span class="math notranslate nohighlight">\((R, t)\)</span> otherwise.</p>
</dd>
</dl>
<p class="rubric">References</p>
<ol class="upperalpha simple" start="19">
<li><p>Umeyama, “Least-squares estimation of transformation parameters between two point patterns,” IEEE Transactions on pattern analysis and machine intelligence, vol. 13, no. 4, Art. no. 4, 1991.</p></li>
</ol>
<ol class="upperalpha simple" start="23">
<li><p>Kabsch, “A solution for the best rotation to relate two sets of vectors”. Acta Crystallographica, A32, 1976.</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.rigid_vectors_registration">
<span class="sig-name descname"><span class="pre">rigid_vectors_registration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.rigid_vectors_registration" title="Link to this definition"></a></dt>
<dd><p>Returns the rotation matrix <span class="math notranslate nohighlight">\(R\)</span> and the optional scaling <span class="math notranslate nohighlight">\(s\)</span> that best align an input list of vectors <span class="math notranslate nohighlight">\((x_i)_{i=1...n}\)</span> to a target list of vectors <span class="math notranslate nohighlight">\((y_i)_{i=1...n}\)</span>
by minimizing the sum of square distance <span class="math notranslate nohighlight">\(\sum_i w_i \|s R x_i - y_i\|^2\)</span>, where <span class="math notranslate nohighlight">\((w_i)_{i=1...n}\)</span> denotes optional positive weights.
See <a class="reference internal" href="#roma.utils.rigid_points_registration" title="roma.utils.rigid_points_registration"><code class="xref py py-func docutils literal notranslate"><span class="pre">rigid_points_registration()</span></code></a> for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>...</em><em>xNxD tensor</em>) – list of N vectors of dimension D.</p></li>
<li><p><strong>y</strong> (<em>...</em><em>xNxD tensor</em>) – list of corresponding target vectors.</p></li>
<li><p><strong>weights</strong> (<em>None</em><em> or </em><em>...</em><em>xN tensor</em>) – optional list of weights associated to each vector.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple <span class="math notranslate nohighlight">\((R, s)\)</span> consisting of the rotation matrix <span class="math notranslate nohighlight">\(R\)</span> (…xDxD tensor) and the scaling <span class="math notranslate nohighlight">\(s\)</span> (… tensor)
if <code class="code docutils literal notranslate"><span class="pre">compute_scaling=True</span></code>.
Returns the rotation matrix <span class="math notranslate nohighlight">\(R\)</span> otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.rotmat_composition">
<span class="sig-name descname"><span class="pre">rotmat_composition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.rotmat_composition" title="Link to this definition"></a></dt>
<dd><p>Returns the product of a sequence of rotation matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sequence</strong> (<em>sequence</em><em> of </em><em>...</em><em>xNxN tensors</em>) – sequence of batches of rotation matrices.</p></li>
<li><p><strong>normalize</strong> – if True, apply special Procrustes orthonormalization to compensate for numerical errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of rotation matrices (…xNxN tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.rotmat_cosine_angle">
<span class="sig-name descname"><span class="pre">rotmat_cosine_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.rotmat_cosine_angle" title="Link to this definition"></a></dt>
<dd><p>Returns the cosine angle of the input 3x3 rotation matrix R.
Based on the equality <span class="math notranslate nohighlight">\(Trace(R) = 1 + 2 cos(alpha)\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>R</strong> (<em>...</em><em>x3x3 tensor</em>) – batch of 3w3 rotation matrices.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of cosine angles (… tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.rotmat_geodesic_distance">
<span class="sig-name descname"><span class="pre">rotmat_geodesic_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.rotmat_geodesic_distance" title="Link to this definition"></a></dt>
<dd><p>Returns the angular distance alpha between a pair of rotation matrices.
Based on the equality <span class="math notranslate nohighlight">\(|R_2 - R_1|_F = 2 \sqrt{2} sin(alpha/2)\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R1</strong> (<em>...</em><em>x3x3 tensor</em>) – batch of 3x3 rotation matrices.</p></li>
<li><p><strong>R2</strong> (<em>...</em><em>x3x3 tensor</em>) – batch of 3x3 rotation matrices.</p></li>
<li><p><strong>clamping</strong> – clamping value applied to the input of <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.asin()</span></code>.
Use 1.0 to ensure valid angular distances.
Use a value strictly smaller than 1.0 to ensure finite gradients.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of angles in radians (… tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.rotmat_geodesic_distance_naive">
<span class="sig-name descname"><span class="pre">rotmat_geodesic_distance_naive</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.rotmat_geodesic_distance_naive" title="Link to this definition"></a></dt>
<dd><p>Returns the angular distance between a pair of rotation matrices.
Based on <a class="reference internal" href="#roma.utils.rotmat_cosine_angle" title="roma.utils.rotmat_cosine_angle"><code class="xref py py-func docutils literal notranslate"><span class="pre">rotmat_cosine_angle()</span></code></a> and less precise than <a class="reference internal" href="#roma.utils.rotmat_geodesic_distance" title="roma.utils.rotmat_geodesic_distance"><code class="xref py py-func docutils literal notranslate"><span class="pre">rotmat_geodesic_distance()</span></code></a> for nearby rotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R1</strong> (<em>...</em><em>x3x3 tensor</em>) – batch of 3x3 rotation matrices.</p></li>
<li><p><strong>R2</strong> (<em>...</em><em>x3x3 tensor</em>) – batch of 3x3 rotation matrices.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of angles in radians (… tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.rotmat_inverse">
<span class="sig-name descname"><span class="pre">rotmat_inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.rotmat_inverse" title="Link to this definition"></a></dt>
<dd><p>Returns the inverse of a rotation matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>R</strong> (<em>...</em><em>xNxN tensor</em>) – batch of rotation matrices.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of inverted rotation matrices (…xNxN tensor).</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The function returns a transposed view of the input, therefore one should be careful with in-place operations.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.rotmat_slerp">
<span class="sig-name descname"><span class="pre">rotmat_slerp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.rotmat_slerp" title="Link to this definition"></a></dt>
<dd><p>Spherical linear interpolation between two rotation matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R0</strong> (<em>Ax3x3 tensor</em>) – batch of rotation matrices (A may contain multiple dimensions).</p></li>
<li><p><strong>R1</strong> (<em>Ax3x3 tensor</em>) – batch of rotation matrices (A may contain multiple dimensions).</p></li>
<li><p><strong>steps</strong> (<em>tensor</em><em> of </em><em>shape B</em>) – interpolation steps, 0.0 corresponding to R0 and 1.0 to R1 (B may contain multiple dimensions).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of interpolated rotation matrices (BxAx3x3 tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.rotvec_composition">
<span class="sig-name descname"><span class="pre">rotvec_composition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sequence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.rotvec_composition" title="Link to this definition"></a></dt>
<dd><p>Returns a rotation vector corresponding to the composition of a sequence of rotations represented by rotation vectors.
Composition is performed using an intermediary quaternion representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sequence</strong> (<em>sequence</em><em> of </em><em>...</em><em>x3 tensors</em>) – sequence of batches of rotation vectors.</p></li>
<li><p><strong>normalize</strong> (<em>bool</em>) – if True, normalize intermediary representation to compensate for numerical errors.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.rotvec_geodesic_distance">
<span class="sig-name descname"><span class="pre">rotvec_geodesic_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vec2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.rotvec_geodesic_distance" title="Link to this definition"></a></dt>
<dd><p>Returns the angular distance between rotations represented by rotation vectors.
(use a conversion to unit quaternions internally).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec1</strong> (<em>...</em><em>x3 tensors</em>) – batch of rotation vectors.</p></li>
<li><p><strong>vec2</strong> (<em>...</em><em>x3 tensors</em>) – batch of rotation vectors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of angles in radians (… tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.rotvec_inverse">
<span class="sig-name descname"><span class="pre">rotvec_inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rotvec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.rotvec_inverse" title="Link to this definition"></a></dt>
<dd><p>Returns the inverse of the input rotation expressed using rotation vector representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>rotvec</strong> (<em>...</em><em>x3 tensor</em>) – batch of rotation vectors.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of rotation vectors (…x3 tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.rotvec_slerp">
<span class="sig-name descname"><span class="pre">rotvec_slerp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rotvec0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotvec1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.rotvec_slerp" title="Link to this definition"></a></dt>
<dd><p>Spherical linear interpolation between two rotation vector representations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rotvec0</strong> (<em>Ax3 tensor</em>) – batch of rotation vectors (A may contain multiple dimensions).</p></li>
<li><p><strong>rotvec1</strong> (<em>Ax3 tensor</em>) – batch of rotation vectors (A may contain multiple dimensions).</p></li>
<li><p><strong>steps</strong> (<em>tensor</em><em> of </em><em>shape B</em>) – interpolation steps, 0.0 corresponding to rotvec0 and 1.0 to rotvec1 (B may contain multiple dimensions).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of interpolated rotation vectors (BxAx3 tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.unitquat_geodesic_distance">
<span class="sig-name descname"><span class="pre">unitquat_geodesic_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.unitquat_geodesic_distance" title="Link to this definition"></a></dt>
<dd><p>Returns the angular distance alpha between rotations represented by <strong>unit</strong> quaternions.
Based on the equality <span class="math notranslate nohighlight">\(min |q_2 \pm q_1| = 2 |sin(alpha/4)|\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q1</strong> (<em>...</em><em>x4 tensor</em><em>, </em><em>XYZW convention</em>) – batch of unit quaternions.</p></li>
<li><p><strong>q2</strong> (<em>...</em><em>x4 tensor</em><em>, </em><em>XYZW convention</em>) – batch of unit quaternions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of angles in radians (… tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.unitquat_slerp">
<span class="sig-name descname"><span class="pre">unitquat_slerp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shortest_arc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.unitquat_slerp" title="Link to this definition"></a></dt>
<dd><p>Spherical linear interpolation between two unit quaternions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q0</strong> (<em>Ax4 tensor</em>) – batch of unit quaternions (A may contain multiple dimensions).</p></li>
<li><p><strong>q1</strong> (<em>Ax4 tensor</em>) – batch of unit quaternions (A may contain multiple dimensions).</p></li>
<li><p><strong>steps</strong> (<em>tensor</em><em> of </em><em>shape B</em>) – interpolation steps, 0.0 corresponding to q0 and 1.0 to q1 (B may contain multiple dimensions).</p></li>
<li><p><strong>shortest_arc</strong> (<em>boolean</em>) – if True, interpolation will be performed along the shortest arc on SO(3) from <cite>q0</cite> to <cite>q1</cite> or <cite>-q1</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of interpolated quaternions (BxAx4 tensor).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When considering quaternions as rotation representations,
one should keep in mind that spherical interpolation is not necessarily performed along the shortest arc,
depending on the sign of <code class="docutils literal notranslate"><span class="pre">torch.sum(q0*q1,dim=-1)</span></code>.</p>
<p>Behavior is undefined when using <code class="docutils literal notranslate"><span class="pre">shortest_arc=False</span></code> with antipodal quaternions.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="roma.utils.unitquat_slerp_fast">
<span class="sig-name descname"><span class="pre">unitquat_slerp_fast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shortest_arc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.utils.unitquat_slerp_fast" title="Link to this definition"></a></dt>
<dd><p>Spherical linear interpolation between two unit quaternions.
This function requires less computations than <a class="reference internal" href="#roma.utils.unitquat_slerp" title="roma.utils.unitquat_slerp"><code class="xref py py-func docutils literal notranslate"><span class="pre">roma.utils.unitquat_slerp()</span></code></a>,
but is <strong>unsuitable for extrapolation (i.e.</strong> <code class="docutils literal notranslate"><span class="pre">steps</span></code> <strong>must be within [0,1])</strong>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q0</strong> (<em>Ax4 tensor</em>) – batch of unit quaternions (A may contain multiple dimensions).</p></li>
<li><p><strong>q1</strong> (<em>Ax4 tensor</em>) – batch of unit quaternions (A may contain multiple dimensions).</p></li>
<li><p><strong>steps</strong> (<em>tensor</em><em> of </em><em>shape B</em>) – interpolation steps within 0.0 and 1.0, 0.0 corresponding to q0 and 1.0 to q1 (B may contain multiple dimensions).</p></li>
<li><p><strong>shortest_arc</strong> (<em>boolean</em>) – if True, interpolation will be performed along the shortest arc on SO(3) from <cite>q0</cite> to <cite>q1</cite> or <cite>-q1</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>batch of interpolated quaternions (BxAx4 tensor).</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-roma.transforms">
<span id="id1"></span><span id="spatial-transformations"></span><h2><a class="toc-backref" href="#id21" role="doc-backlink">Spatial transformations</a><a class="headerlink" href="#module-roma.transforms" title="Link to this heading"></a></h2>
<p>Spatial transformations parameterized by rotation matrices, unit quaternions and more.</p>
<section id="example-of-use">
<h3><a class="toc-backref" href="#id22" role="doc-backlink">Example of use</a><a class="headerlink" href="#example-of-use" title="Link to this heading"></a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span><span class="o">,</span><span class="w"> </span><span class="nn">roma</span>
<span class="c1"># Rigid transformation parameterized by a rotation matrix and a translation vector</span>
<span class="n">T0</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">Rigid</span><span class="p">(</span><span class="n">linear</span><span class="o">=</span><span class="n">roma</span><span class="o">.</span><span class="n">random_rotmat</span><span class="p">(),</span> <span class="n">translation</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>

<span class="c1"># Rigid transformations parameterized by a unit quaternion and a translation vector</span>
<span class="n">T1</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">RigidUnitQuat</span><span class="p">(</span><span class="n">linear</span><span class="o">=</span><span class="n">roma</span><span class="o">.</span><span class="n">random_unitquat</span><span class="p">(),</span> <span class="n">translation</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="n">T2</span> <span class="o">=</span> <span class="n">roma</span><span class="o">.</span><span class="n">RigidUnitQuat</span><span class="p">(</span><span class="n">linear</span><span class="o">=</span><span class="n">roma</span><span class="o">.</span><span class="n">random_unitquat</span><span class="p">(),</span> <span class="n">translation</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>

<span class="c1"># Inverting and composing transformations</span>
<span class="n">T</span> <span class="o">=</span> <span class="p">(</span><span class="n">T1</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span> <span class="o">@</span> <span class="n">T2</span><span class="p">)</span>

<span class="c1"># Normalization to ensure that T is actually a rigid transformation.</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>

<span class="c1"># Direct access to the translation part</span>
<span class="n">T</span><span class="o">.</span><span class="n">translation</span> <span class="o">+=</span> <span class="mf">0.5</span>

<span class="c1"># Transformation of points:</span>
<span class="n">points</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="c1"># Adjusting the shape of T for proper broadcasting.</span>
<span class="n">transformed_points</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

<span class="c1"># Transformation of vectors:</span>
<span class="n">vectors</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="c1"># Adjusting the shape of T for proper broadcasting.</span>
<span class="n">transformed_vectors</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">linear_apply</span><span class="p">(</span><span class="n">vectors</span><span class="p">)</span>

<span class="c1"># Casting the transformation into an homogeneous 4x4 matrix.</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">to_homogeneous</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="applying-a-transformation">
<span id="apply-transformation"></span><h3><a class="toc-backref" href="#id23" role="doc-backlink">Applying a transformation</a><a class="headerlink" href="#applying-a-transformation" title="Link to this heading"></a></h3>
<p>When applying a transformation to a set of points of coordinates <code class="code docutils literal notranslate"><span class="pre">v</span></code>,
The batch shape of <code class="code docutils literal notranslate"><span class="pre">v</span></code> should be broadcastable with the batch shape of the transformation.</p>
<p>For example, one can sample a unique random rigid 3D transformation and use it to transform 100 random 3D points as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">roma</span><span class="o">.</span><span class="n">Rigid</span><span class="p">(</span><span class="n">roma</span><span class="o">.</span><span class="n">random_rotmat</span><span class="p">(),</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">))[</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p>To apply a different transformation to each point, one could use instead:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">roma</span><span class="o">.</span><span class="n">Rigid</span><span class="p">(</span><span class="n">roma</span><span class="o">.</span><span class="n">random_rotmat</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="aliasing-issues">
<span id="id2"></span><h3><a class="toc-backref" href="#id24" role="doc-backlink">Aliasing issues</a><a class="headerlink" href="#aliasing-issues" title="Link to this heading"></a></h3>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>For efficiency reasons, transformation objects do not copy input data. Be careful if you intend to do some in-place data modifications, and use the <code class="code docutils literal notranslate"><span class="pre">clone()</span></code> method when required.</p>
</div>
</section>
<dl class="py class">
<dt class="sig sig-object py" id="roma.transforms.Affine">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Affine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">linear</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Affine" title="Link to this definition"></a></dt>
<dd><p>An affine transformation represented by a linear and a translation part.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>linear</strong> – (…xCxD tensor): batch of matrices specifying the linear part.</p></li>
<li><p><strong>translation</strong> – (…xD tensor or None): batch of matrices specifying the translation part.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Affine.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Affine.apply" title="Link to this definition"></a></dt>
<dd><p>Transforms a tensor of points coordinates. See <a class="reference internal" href="#apply-transformation"><span class="std std-ref">Applying a transformation</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>...</em><em>xD tensor</em>) – tensor of point coordinates to transform.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transformed point coordinates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Affine.as_tuple">
<span class="sig-name descname"><span class="pre">as_tuple</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Affine.as_tuple" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a tuple of tensors containing the linear and translation parts of the transformation respectively.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Affine.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Affine.clone" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A copy of the transformation (useful to avoid aliasing issues).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Affine.compose">
<span class="sig-name descname"><span class="pre">compose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Affine.compose" title="Link to this definition"></a></dt>
<dd><p>Compose a transformation with the current one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – an other transformation of same type.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Affine.from_homogeneous">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_homogeneous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Affine.from_homogeneous" title="Link to this definition"></a></dt>
<dd><p>Instantiate a new transformation from an input homogeneous (D+1)x(C+1) matrix.
The input matrix is assumed to be normalized and to satisfy the properties of the transformation. No checks are performed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>matrix</strong> (<em>...</em><em>x</em><em>(</em><em>D+1</em><em>)</em><em>x</em><em>(</em><em>C+1</em><em>) </em><em>tensor</em>) – tensor of transformations expressed in homogeneous coordinates, normalized with a last row equal to (0,…,0,1).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The corresponding transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Affine.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Affine.inverse" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The inverse transformation, when applicable.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Affine.linear_apply">
<span class="sig-name descname"><span class="pre">linear_apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Affine.linear_apply" title="Link to this definition"></a></dt>
<dd><p>Transforms a tensor of vector coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>...</em><em>xD tensor</em>) – tensor of vector coordinates to transform.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transformed vector coordinates.</p>
</dd>
</dl>
<p>See note in <a class="reference internal" href="#roma.transforms.Linear.apply" title="roma.transforms.Linear.apply"><code class="xref py py-func docutils literal notranslate"><span class="pre">apply()</span></code></a> regarding broadcasting.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Affine.linear_compose">
<span class="sig-name descname"><span class="pre">linear_compose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Affine.linear_compose" title="Link to this definition"></a></dt>
<dd><p>Compose the linear part of two transformations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – an other transformation of same type.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a tensor representing the composed transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Affine.linear_inverse">
<span class="sig-name descname"><span class="pre">linear_inverse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Affine.linear_inverse" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The inverse of the linear transformation, when applicable.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Affine.normalize">
<span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Affine.normalize" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Copy of the transformation, normalized to ensure the class properties
(for example to ensure that a <a class="reference internal" href="#roma.transforms.Rotation" title="roma.transforms.Rotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rotation</span></code></a> object is an actual rotation).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Affine.squeeze">
<span class="sig-name descname"><span class="pre">squeeze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Affine.squeeze" title="Link to this definition"></a></dt>
<dd><p>Return a view of the transformation in which a batch dimension equal to 1 has been squeezed.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dim</strong> – positive integer: The dimension to squeeze.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Affine.to_homogeneous">
<span class="sig-name descname"><span class="pre">to_homogeneous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Affine.to_homogeneous" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>output</strong> (<em>...</em><em>x</em><em>(</em><em>D+1</em><em>)</em><em>x</em><em>(</em><em>C+1</em><em>) </em><em>tensor</em><em> or </em><em>None</em>) – optional tensor in which to store the result.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A …x(D+1)x(C+1) tensor of homogeneous matrices representing the transformation, normalized with a last row equal to (0,…,0,1).</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="roma.transforms.Isometry">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Isometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">linear</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Isometry" title="Link to this definition"></a></dt>
<dd><p>An isometric transformation represented by an orthonormal and a translation part.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>linear</strong> – (…xDxD tensor or None): batch of matrices specifying the linear part.</p></li>
<li><p><strong>translation</strong> – (…xD tensor or None): batch of matrices specifying the translation part.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Isometry.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Isometry.apply" title="Link to this definition"></a></dt>
<dd><p>Transforms a tensor of points coordinates. See <a class="reference internal" href="#apply-transformation"><span class="std std-ref">Applying a transformation</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>...</em><em>xD tensor</em>) – tensor of point coordinates to transform.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transformed point coordinates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Isometry.as_tuple">
<span class="sig-name descname"><span class="pre">as_tuple</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Isometry.as_tuple" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a tuple of tensors containing the linear and translation parts of the transformation respectively.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Isometry.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Isometry.clone" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A copy of the transformation (useful to avoid aliasing issues).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Isometry.compose">
<span class="sig-name descname"><span class="pre">compose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Isometry.compose" title="Link to this definition"></a></dt>
<dd><p>Compose a transformation with the current one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – an other transformation of same type.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Isometry.from_homogeneous">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_homogeneous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Isometry.from_homogeneous" title="Link to this definition"></a></dt>
<dd><p>Instantiate a new transformation from an input homogeneous (D+1)x(C+1) matrix.
The input matrix is assumed to be normalized and to satisfy the properties of the transformation. No checks are performed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>matrix</strong> (<em>...</em><em>x</em><em>(</em><em>D+1</em><em>)</em><em>x</em><em>(</em><em>C+1</em><em>) </em><em>tensor</em>) – tensor of transformations expressed in homogeneous coordinates, normalized with a last row equal to (0,…,0,1).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The corresponding transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Isometry.identity">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">identity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">torch.float32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Isometry.identity" title="Link to this definition"></a></dt>
<dd><p>Return a default identity transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> – (strictly positive integer): dimension of the space in which the transformation operates (e.g. <cite>dim=3</cite> for 3D transformations).</p></li>
<li><p><strong>batch_shape</strong> – (tuple): batch dimensions considered.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Isometry.identity_like">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">identity_like</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Isometry.identity_like" title="Link to this definition"></a></dt>
<dd><p>Return an identity transformation with the same batch shape, type and device as the input transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – (Isometry): input transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Isometry.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Isometry.inverse" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The inverse transformation, when applicable.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Isometry.linear_apply">
<span class="sig-name descname"><span class="pre">linear_apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Isometry.linear_apply" title="Link to this definition"></a></dt>
<dd><p>Transforms a tensor of vector coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>...</em><em>xD tensor</em>) – tensor of vector coordinates to transform.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transformed vector coordinates.</p>
</dd>
</dl>
<p>See note in <a class="reference internal" href="#roma.transforms.Linear.apply" title="roma.transforms.Linear.apply"><code class="xref py py-func docutils literal notranslate"><span class="pre">apply()</span></code></a> regarding broadcasting.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Isometry.linear_compose">
<span class="sig-name descname"><span class="pre">linear_compose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Isometry.linear_compose" title="Link to this definition"></a></dt>
<dd><p>Compose the linear part of two transformations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – an other transformation of same type.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a tensor representing the composed transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Isometry.linear_inverse">
<span class="sig-name descname"><span class="pre">linear_inverse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Isometry.linear_inverse" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The inverse of the linear transformation, when applicable.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Isometry.linear_normalize">
<span class="sig-name descname"><span class="pre">linear_normalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Isometry.linear_normalize" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Linear transformation normalized to an orthonormal matrix (…xDxD tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Isometry.normalize">
<span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Isometry.normalize" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Copy of the transformation, normalized to ensure the class properties
(for example to ensure that a <a class="reference internal" href="#roma.transforms.Rotation" title="roma.transforms.Rotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rotation</span></code></a> object is an actual rotation).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Isometry.squeeze">
<span class="sig-name descname"><span class="pre">squeeze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Isometry.squeeze" title="Link to this definition"></a></dt>
<dd><p>Return a view of the transformation in which a batch dimension equal to 1 has been squeezed.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dim</strong> – positive integer: The dimension to squeeze.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Isometry.to_homogeneous">
<span class="sig-name descname"><span class="pre">to_homogeneous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Isometry.to_homogeneous" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>output</strong> (<em>...</em><em>x</em><em>(</em><em>D+1</em><em>)</em><em>x</em><em>(</em><em>C+1</em><em>) </em><em>tensor</em><em> or </em><em>None</em>) – optional tensor in which to store the result.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A …x(D+1)x(C+1) tensor of homogeneous matrices representing the transformation, normalized with a last row equal to (0,…,0,1).</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="roma.transforms.Linear">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Linear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">linear</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Linear" title="Link to this definition"></a></dt>
<dd><p>A linear transformation parameterized by a matrix <span class="math notranslate nohighlight">\(M \in \mathcal{M}_{D,C}(\mathbb{R})\)</span>,
transforming a point <span class="math notranslate nohighlight">\(x \in \mathbb{R}^C\)</span> into <span class="math notranslate nohighlight">\(M x\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>linear</strong> – (…xDxC tensor): batch of matrices specifying the transformations considered.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Linear.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Linear.apply" title="Link to this definition"></a></dt>
<dd><p>Transforms a tensor of points coordinates. See <a class="reference internal" href="#apply-transformation"><span class="std std-ref">Applying a transformation</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>...</em><em>xD tensor</em>) – tensor of point coordinates to transform.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transformed point coordinates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Linear.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Linear.clone" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A copy of the transformation (useful to avoid aliasing issues).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Linear.compose">
<span class="sig-name descname"><span class="pre">compose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Linear.compose" title="Link to this definition"></a></dt>
<dd><p>Compose a transformation with the current one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – an other transformation of same type.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Linear.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Linear.inverse" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The inverse transformation, when applicable.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Linear.linear_apply">
<span class="sig-name descname"><span class="pre">linear_apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Linear.linear_apply" title="Link to this definition"></a></dt>
<dd><p>Transforms a tensor of vector coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>...</em><em>xD tensor</em>) – tensor of vector coordinates to transform.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transformed vector coordinates.</p>
</dd>
</dl>
<p>See note in <a class="reference internal" href="#roma.transforms.Linear.apply" title="roma.transforms.Linear.apply"><code class="xref py py-func docutils literal notranslate"><span class="pre">apply()</span></code></a> regarding broadcasting.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Linear.linear_compose">
<span class="sig-name descname"><span class="pre">linear_compose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Linear.linear_compose" title="Link to this definition"></a></dt>
<dd><p>Compose the linear part of two transformations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – an other transformation of same type.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a tensor representing the composed transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Linear.linear_inverse">
<span class="sig-name descname"><span class="pre">linear_inverse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Linear.linear_inverse" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The inverse of the linear transformation, when applicable.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Linear.normalize">
<span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Linear.normalize" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Copy of the transformation, normalized to ensure the class properties
(for example to ensure that a <a class="reference internal" href="#roma.transforms.Rotation" title="roma.transforms.Rotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rotation</span></code></a> object is an actual rotation).</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="roma.transforms.Orthonormal">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Orthonormal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">linear</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Orthonormal" title="Link to this definition"></a></dt>
<dd><p>An orthogonal transformation represented by an orthonormal matrix <span class="math notranslate nohighlight">\(M \in \mathcal{M}_{D,D}(\mathbb{R})\)</span>,
transforming a point <span class="math notranslate nohighlight">\(x \in \mathbb{R}^D\)</span> into <span class="math notranslate nohighlight">\(M x\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>linear</strong> – (…xDxD tensor): batch of matrices <span class="math notranslate nohighlight">\(M\)</span> specifying the transformations considered.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Orthonormal.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Orthonormal.apply" title="Link to this definition"></a></dt>
<dd><p>Transforms a tensor of points coordinates. See <a class="reference internal" href="#apply-transformation"><span class="std std-ref">Applying a transformation</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>...</em><em>xD tensor</em>) – tensor of point coordinates to transform.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transformed point coordinates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Orthonormal.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Orthonormal.clone" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A copy of the transformation (useful to avoid aliasing issues).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Orthonormal.compose">
<span class="sig-name descname"><span class="pre">compose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Orthonormal.compose" title="Link to this definition"></a></dt>
<dd><p>Compose a transformation with the current one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – an other transformation of same type.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Orthonormal.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Orthonormal.inverse" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The inverse transformation, when applicable.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Orthonormal.linear_apply">
<span class="sig-name descname"><span class="pre">linear_apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Orthonormal.linear_apply" title="Link to this definition"></a></dt>
<dd><p>Transforms a tensor of vector coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>...</em><em>xD tensor</em>) – tensor of vector coordinates to transform.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transformed vector coordinates.</p>
</dd>
</dl>
<p>See note in <a class="reference internal" href="#roma.transforms.Linear.apply" title="roma.transforms.Linear.apply"><code class="xref py py-func docutils literal notranslate"><span class="pre">apply()</span></code></a> regarding broadcasting.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Orthonormal.linear_compose">
<span class="sig-name descname"><span class="pre">linear_compose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Orthonormal.linear_compose" title="Link to this definition"></a></dt>
<dd><p>Compose the linear part of two transformations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – an other transformation of same type.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a tensor representing the composed transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Orthonormal.linear_inverse">
<span class="sig-name descname"><span class="pre">linear_inverse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Orthonormal.linear_inverse" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The inverse of the linear transformation, when applicable.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Orthonormal.linear_normalize">
<span class="sig-name descname"><span class="pre">linear_normalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Orthonormal.linear_normalize" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Linear transformation normalized to an orthonormal matrix (…xDxD tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Orthonormal.normalize">
<span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Orthonormal.normalize" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Copy of the transformation, normalized to ensure the class properties
(for example to ensure that a <a class="reference internal" href="#roma.transforms.Rotation" title="roma.transforms.Rotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rotation</span></code></a> object is an actual rotation).</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="roma.transforms.Rigid">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Rigid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">linear</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rigid" title="Link to this definition"></a></dt>
<dd><p>A rigid transformation represented by an rotation and a translation part.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>linear</strong> – (…xDxD tensor or None): batch of matrices specifying the linear part.</p></li>
<li><p><strong>translation</strong> – (…xD tensor or None): batch of matrices specifying the translation part.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rigid.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rigid.apply" title="Link to this definition"></a></dt>
<dd><p>Transforms a tensor of points coordinates. See <a class="reference internal" href="#apply-transformation"><span class="std std-ref">Applying a transformation</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>...</em><em>xD tensor</em>) – tensor of point coordinates to transform.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transformed point coordinates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rigid.as_tuple">
<span class="sig-name descname"><span class="pre">as_tuple</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rigid.as_tuple" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a tuple of tensors containing the linear and translation parts of the transformation respectively.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rigid.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rigid.clone" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A copy of the transformation (useful to avoid aliasing issues).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rigid.compose">
<span class="sig-name descname"><span class="pre">compose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rigid.compose" title="Link to this definition"></a></dt>
<dd><p>Compose a transformation with the current one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – an other transformation of same type.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rigid.from_homogeneous">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_homogeneous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rigid.from_homogeneous" title="Link to this definition"></a></dt>
<dd><p>Instantiate a new transformation from an input homogeneous (D+1)x(C+1) matrix.
The input matrix is assumed to be normalized and to satisfy the properties of the transformation. No checks are performed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>matrix</strong> (<em>...</em><em>x</em><em>(</em><em>D+1</em><em>)</em><em>x</em><em>(</em><em>C+1</em><em>) </em><em>tensor</em>) – tensor of transformations expressed in homogeneous coordinates, normalized with a last row equal to (0,…,0,1).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The corresponding transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rigid.identity">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">identity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">torch.float32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rigid.identity" title="Link to this definition"></a></dt>
<dd><p>Return a default identity transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> – (strictly positive integer): dimension of the space in which the transformation operates (e.g. <cite>dim=3</cite> for 3D transformations).</p></li>
<li><p><strong>batch_shape</strong> – (tuple): batch dimensions considered.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rigid.identity_like">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">identity_like</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rigid.identity_like" title="Link to this definition"></a></dt>
<dd><p>Return an identity transformation with the same batch shape, type and device as the input transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – (Isometry): input transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rigid.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rigid.inverse" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The inverse transformation, when applicable.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rigid.linear_apply">
<span class="sig-name descname"><span class="pre">linear_apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rigid.linear_apply" title="Link to this definition"></a></dt>
<dd><p>Transforms a tensor of vector coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>...</em><em>xD tensor</em>) – tensor of vector coordinates to transform.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transformed vector coordinates.</p>
</dd>
</dl>
<p>See note in <a class="reference internal" href="#roma.transforms.Linear.apply" title="roma.transforms.Linear.apply"><code class="xref py py-func docutils literal notranslate"><span class="pre">apply()</span></code></a> regarding broadcasting.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rigid.linear_compose">
<span class="sig-name descname"><span class="pre">linear_compose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rigid.linear_compose" title="Link to this definition"></a></dt>
<dd><p>Compose the linear part of two transformations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – an other transformation of same type.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a tensor representing the composed transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rigid.linear_inverse">
<span class="sig-name descname"><span class="pre">linear_inverse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rigid.linear_inverse" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The inverse of the linear transformation, when applicable.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rigid.linear_normalize">
<span class="sig-name descname"><span class="pre">linear_normalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rigid.linear_normalize" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Linear transformation normalized to a rotation matrix (…xDxD tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rigid.normalize">
<span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rigid.normalize" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Copy of the transformation, normalized to ensure the class properties
(for example to ensure that a <a class="reference internal" href="#roma.transforms.Rotation" title="roma.transforms.Rotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rotation</span></code></a> object is an actual rotation).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rigid.squeeze">
<span class="sig-name descname"><span class="pre">squeeze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rigid.squeeze" title="Link to this definition"></a></dt>
<dd><p>Return a view of the transformation in which a batch dimension equal to 1 has been squeezed.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dim</strong> – positive integer: The dimension to squeeze.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rigid.to_homogeneous">
<span class="sig-name descname"><span class="pre">to_homogeneous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rigid.to_homogeneous" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>output</strong> (<em>...</em><em>x</em><em>(</em><em>D+1</em><em>)</em><em>x</em><em>(</em><em>C+1</em><em>) </em><em>tensor</em><em> or </em><em>None</em>) – optional tensor in which to store the result.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A …x(D+1)x(C+1) tensor of homogeneous matrices representing the transformation, normalized with a last row equal to (0,…,0,1).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rigid.to_rigidunitquat">
<span class="sig-name descname"><span class="pre">to_rigidunitquat</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rigid.to_rigidunitquat" title="Link to this definition"></a></dt>
<dd><p>Returns the corresponding RigidUnitQuat transformation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Original and resulting transformations share the same translation tensor. Be careful in case of in-place modifications.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="roma.transforms.RigidUnitQuat">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RigidUnitQuat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">linear</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RigidUnitQuat" title="Link to this definition"></a></dt>
<dd><p>A rigid transformation represented by a unit quaternion and a translation part.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>linear</strong> – (…x4 tensor): batch of unit quaternions defining the rotation.</p></li>
<li><p><strong>translation</strong> – (…x3 tensor): batch of matrices specifying the translation part.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Quaternions are assumed to be of unit norm, for all internal operations.
Use the <code class="code docutils literal notranslate"><span class="pre">normalize()</span></code> method if needed.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.RigidUnitQuat.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RigidUnitQuat.apply" title="Link to this definition"></a></dt>
<dd><p>Transforms a tensor of points coordinates. See <a class="reference internal" href="#apply-transformation"><span class="std std-ref">Applying a transformation</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>...</em><em>xD tensor</em>) – tensor of point coordinates to transform.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transformed point coordinates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.RigidUnitQuat.as_tuple">
<span class="sig-name descname"><span class="pre">as_tuple</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RigidUnitQuat.as_tuple" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a tuple of tensors containing the linear and translation parts of the transformation respectively.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.RigidUnitQuat.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RigidUnitQuat.clone" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A copy of the transformation (useful to avoid aliasing issues).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.RigidUnitQuat.compose">
<span class="sig-name descname"><span class="pre">compose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RigidUnitQuat.compose" title="Link to this definition"></a></dt>
<dd><p>Compose a transformation with the current one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – an other transformation of same type.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.RigidUnitQuat.from_homogeneous">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_homogeneous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RigidUnitQuat.from_homogeneous" title="Link to this definition"></a></dt>
<dd><p>Instantiate a new transformation from an input homogeneous (D+1)x(D+1) matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>matrix</strong> (<em>...</em><em>x</em><em>(</em><em>D+1</em><em>)</em><em>x</em><em>(</em><em>D+1</em><em>) </em><em>tensor</em>) – tensor of transformations expressed in homogeneous coordinates, normalized with a last row equal to (0,…,0,1).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The corresponding transformation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>The input matrix is not tested to ensure that it satisfies the required properties of the transformation.</p></li>
<li><p>Components of the resulting transformation may consist in views of the input matrix. Be careful if you intend to modify it in-place.</p></li>
</ul>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.RigidUnitQuat.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RigidUnitQuat.inverse" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The inverse transformation, when applicable.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.RigidUnitQuat.linear_apply">
<span class="sig-name descname"><span class="pre">linear_apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RigidUnitQuat.linear_apply" title="Link to this definition"></a></dt>
<dd><p>Transforms a tensor of vector coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>...</em><em>xD tensor</em>) – tensor of vector coordinates to transform.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transformed vector coordinates.</p>
</dd>
</dl>
<p>See note in <a class="reference internal" href="#roma.transforms.Linear.apply" title="roma.transforms.Linear.apply"><code class="xref py py-func docutils literal notranslate"><span class="pre">apply()</span></code></a> regarding broadcasting.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.RigidUnitQuat.linear_compose">
<span class="sig-name descname"><span class="pre">linear_compose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RigidUnitQuat.linear_compose" title="Link to this definition"></a></dt>
<dd><p>Compose the linear part of two transformations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – an other transformation of same type.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a tensor representing the composed transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.RigidUnitQuat.linear_inverse">
<span class="sig-name descname"><span class="pre">linear_inverse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RigidUnitQuat.linear_inverse" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The inverse of the linear transformation, when applicable.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.RigidUnitQuat.linear_normalize">
<span class="sig-name descname"><span class="pre">linear_normalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RigidUnitQuat.linear_normalize" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Normalized unit quaternion (…x4 tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.RigidUnitQuat.normalize">
<span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RigidUnitQuat.normalize" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Copy of the transformation, normalized to ensure the class properties
(for example to ensure that a <a class="reference internal" href="#roma.transforms.Rotation" title="roma.transforms.Rotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rotation</span></code></a> object is an actual rotation).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.RigidUnitQuat.squeeze">
<span class="sig-name descname"><span class="pre">squeeze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RigidUnitQuat.squeeze" title="Link to this definition"></a></dt>
<dd><p>Return a view of the transformation in which a batch dimension equal to 1 has been squeezed.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dim</strong> – positive integer: The dimension to squeeze.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.RigidUnitQuat.to_homogeneous">
<span class="sig-name descname"><span class="pre">to_homogeneous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RigidUnitQuat.to_homogeneous" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>output</strong> (<em>...</em><em>x4x4 tensor</em><em> or </em><em>None</em>) – tensor in which to store the result (optional).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A …x4x4 tensor of homogeneous matrices representing the transformation, normalized with a last row equal to (0,…,0,1).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.RigidUnitQuat.to_rigid">
<span class="sig-name descname"><span class="pre">to_rigid</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RigidUnitQuat.to_rigid" title="Link to this definition"></a></dt>
<dd><p>Returns the corresponding Rigid transformation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Original and resulting transformations share the same translation tensor. Be careful in case of in-place modifications.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="roma.transforms.Rotation">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Rotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">linear</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rotation" title="Link to this definition"></a></dt>
<dd><p>A rotation represented by a rotation matrix <span class="math notranslate nohighlight">\(R \in \mathcal{M}_{D,D}(\mathbb{R})\)</span>,
transforming a point <span class="math notranslate nohighlight">\(x \in \mathbb{R}^D\)</span> into <span class="math notranslate nohighlight">\(R x\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>linear</strong> – (…xDxD tensor): batch of matrices <span class="math notranslate nohighlight">\(R\)</span> defining the rotation.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rotation.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rotation.apply" title="Link to this definition"></a></dt>
<dd><p>Transforms a tensor of points coordinates. See <a class="reference internal" href="#apply-transformation"><span class="std std-ref">Applying a transformation</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>...</em><em>xD tensor</em>) – tensor of point coordinates to transform.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transformed point coordinates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rotation.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rotation.clone" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A copy of the transformation (useful to avoid aliasing issues).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rotation.compose">
<span class="sig-name descname"><span class="pre">compose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rotation.compose" title="Link to this definition"></a></dt>
<dd><p>Compose a transformation with the current one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – an other transformation of same type.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rotation.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rotation.inverse" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The inverse transformation, when applicable.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rotation.linear_apply">
<span class="sig-name descname"><span class="pre">linear_apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rotation.linear_apply" title="Link to this definition"></a></dt>
<dd><p>Transforms a tensor of vector coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>...</em><em>xD tensor</em>) – tensor of vector coordinates to transform.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transformed vector coordinates.</p>
</dd>
</dl>
<p>See note in <a class="reference internal" href="#roma.transforms.Linear.apply" title="roma.transforms.Linear.apply"><code class="xref py py-func docutils literal notranslate"><span class="pre">apply()</span></code></a> regarding broadcasting.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rotation.linear_compose">
<span class="sig-name descname"><span class="pre">linear_compose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rotation.linear_compose" title="Link to this definition"></a></dt>
<dd><p>Compose the linear part of two transformations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – an other transformation of same type.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a tensor representing the composed transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rotation.linear_inverse">
<span class="sig-name descname"><span class="pre">linear_inverse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rotation.linear_inverse" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The inverse of the linear transformation, when applicable.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rotation.linear_normalize">
<span class="sig-name descname"><span class="pre">linear_normalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rotation.linear_normalize" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Linear transformation normalized to a rotation matrix (…xDxD tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.Rotation.normalize">
<span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.Rotation.normalize" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Copy of the transformation, normalized to ensure the class properties
(for example to ensure that a <a class="reference internal" href="#roma.transforms.Rotation" title="roma.transforms.Rotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rotation</span></code></a> object is an actual rotation).</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="roma.transforms.RotationUnitQuat">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RotationUnitQuat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">linear</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RotationUnitQuat" title="Link to this definition"></a></dt>
<dd><p>A 3D rotation represented by a unit quaternion.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>linear</strong> – (…x4 tensor, XYZW convention): batch of unit quaternions defining the rotation.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Quaternions are assumed to be of unit norm, for all internal operations.
Use <code class="code docutils literal notranslate"><span class="pre">normalize()</span></code> if needed.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.RotationUnitQuat.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RotationUnitQuat.apply" title="Link to this definition"></a></dt>
<dd><p>Transforms a tensor of points coordinates. See <a class="reference internal" href="#apply-transformation"><span class="std std-ref">Applying a transformation</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>...</em><em>xD tensor</em>) – tensor of point coordinates to transform.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transformed point coordinates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.RotationUnitQuat.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RotationUnitQuat.clone" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A copy of the transformation (useful to avoid aliasing issues).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.RotationUnitQuat.compose">
<span class="sig-name descname"><span class="pre">compose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RotationUnitQuat.compose" title="Link to this definition"></a></dt>
<dd><p>Compose a transformation with the current one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – an other transformation of same type.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.RotationUnitQuat.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RotationUnitQuat.inverse" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The inverse transformation, when applicable.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.RotationUnitQuat.linear_apply">
<span class="sig-name descname"><span class="pre">linear_apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RotationUnitQuat.linear_apply" title="Link to this definition"></a></dt>
<dd><p>Transforms a tensor of vector coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>...</em><em>xD tensor</em>) – tensor of vector coordinates to transform.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transformed vector coordinates.</p>
</dd>
</dl>
<p>See note in <a class="reference internal" href="#roma.transforms.Linear.apply" title="roma.transforms.Linear.apply"><code class="xref py py-func docutils literal notranslate"><span class="pre">apply()</span></code></a> regarding broadcasting.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.RotationUnitQuat.linear_compose">
<span class="sig-name descname"><span class="pre">linear_compose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RotationUnitQuat.linear_compose" title="Link to this definition"></a></dt>
<dd><p>Compose the linear part of two transformations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – an other transformation of same type.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a tensor representing the composed transformation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.RotationUnitQuat.linear_inverse">
<span class="sig-name descname"><span class="pre">linear_inverse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RotationUnitQuat.linear_inverse" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The inverse of the linear transformation, when applicable.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.RotationUnitQuat.linear_normalize">
<span class="sig-name descname"><span class="pre">linear_normalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RotationUnitQuat.linear_normalize" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Normalized unit quaternion (…x4 tensor).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="roma.transforms.RotationUnitQuat.normalize">
<span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#roma.transforms.RotationUnitQuat.normalize" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Copy of the transformation, normalized to ensure the class properties
(for example to ensure that a <a class="reference internal" href="#roma.transforms.Rotation" title="roma.transforms.Rotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rotation</span></code></a> object is an actual rotation).</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="advanced">
<h1><a class="toc-backref" href="#id25" role="doc-backlink">Advanced</a><a class="headerlink" href="#advanced" title="Link to this heading"></a></h1>
<section id="running-unit-tests">
<h2><a class="toc-backref" href="#id26" role="doc-backlink">Running unit tests</a><a class="headerlink" href="#running-unit-tests" title="Link to this heading"></a></h2>
<p>from source repository:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span>
</pre></div>
</div>
</section>
<section id="building-sphinx-documentation">
<h2><a class="toc-backref" href="#id27" role="doc-backlink">Building Sphinx documentation</a><a class="headerlink" href="#building-sphinx-documentation" title="Link to this heading"></a></h2>
<p>From source repository:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">build_doc</span><span class="o">.</span><span class="n">sh</span>
</pre></div>
</div>
</section>
</section>
<section id="license">
<h1><a class="toc-backref" href="#id28" role="doc-backlink">License</a><a class="headerlink" href="#license" title="Link to this heading"></a></h1>
<p><em>RoMa</em>, Copyright (c) 2020 NAVER Corp., is licensed under the 3-Clause BSD License (see <a class="reference external" href="https://github.com/naver/roma/blob/master/LICENSE">license</a>).</p>
<p>Bits of code were adapted from SciPy. Documentation is generated, distributed and displayed with the support of Sphinx and other materials (see <a class="reference external" href="https://github.com/naver/roma/blob/master/NOTICE">notice</a>).</p>
</section>
<section id="changelog">
<h1><a class="toc-backref" href="#id29" role="doc-backlink">Changelog</a><a class="headerlink" href="#changelog" title="Link to this heading"></a></h1>
<dl class="simple">
<dt>Version 1.5.3:</dt><dd><ul class="simple">
<li><p>Introduced <code class="docutils literal notranslate"><span class="pre">roma.Isometry.identity</span></code> and <code class="docutils literal notranslate"><span class="pre">roma.Isometry.identity_like</span></code> (<code class="docutils literal notranslate"><span class="pre">roma.Isometry.Identity</span></code> is now deprecated).</p></li>
<li><p>Minor fixes.</p></li>
</ul>
</dd>
<dt>Version 1.5.2:</dt><dd><ul class="simple">
<li><p>Use raw docstrings to avoid ‘SyntaxWarning: invalid escape sequence’ messages with Python&gt;=3.12 (thanks chenzhek for the suggestion).</p></li>
</ul>
</dd>
<dt>Version 1.5.1:</dt><dd><ul class="simple">
<li><p>Syntactic sugar for <a class="reference internal" href="#spatial-transformations"><span class="std std-ref">Spatial transformations</span></a>: support for default linear or translation parts, identity transformations and batch dimension squeezing.</p></li>
</ul>
</dd>
<dt>Version 1.5.0:</dt><dd><ul class="simple">
<li><p>Added Euler angles mappings.</p></li>
</ul>
</dd>
<dt>Version 1.4.5:</dt><dd><ul class="simple">
<li><p>3-Clause BSD Licensing.</p></li>
</ul>
</dd>
<dt>Version 1.4.4:</dt><dd><ul class="simple">
<li><p>Added <a class="reference internal" href="#roma.utils.identity_quat" title="roma.utils.identity_quat"><code class="xref py py-func docutils literal notranslate"><span class="pre">identity_quat()</span></code></a>.</p></li>
</ul>
</dd>
<dt>Version 1.4.3:</dt><dd><ul class="simple">
<li><p>Fix normalization bug in <a class="reference internal" href="#roma.utils.quat_composition" title="roma.utils.quat_composition"><code class="xref py py-func docutils literal notranslate"><span class="pre">quat_composition()</span></code></a> (thanks jamiesalter for reporting).</p></li>
</ul>
</dd>
<dt>Version 1.4.2:</dt><dd><ul class="simple">
<li><p>Fix for <a class="reference internal" href="#roma.utils.quat_action" title="roma.utils.quat_action"><code class="xref py py-func docutils literal notranslate"><span class="pre">quat_action()</span></code></a> to support arbitrary devices and types.</p></li>
<li><p>Added conversion functions between Rigid and RigidUnitQuat.</p></li>
</ul>
</dd>
<dt>Version 1.4.1:</dt><dd><ul class="simple">
<li><p>Added XYZW / WXYZ quaternion conversion routines: <a class="reference internal" href="#roma.mappings.quat_xyzw_to_wxyz" title="roma.mappings.quat_xyzw_to_wxyz"><code class="xref py py-func docutils literal notranslate"><span class="pre">quat_xyzw_to_wxyz()</span></code></a> and <a class="reference internal" href="#roma.mappings.quat_wxyz_to_xyzw" title="roma.mappings.quat_wxyz_to_xyzw"><code class="xref py py-func docutils literal notranslate"><span class="pre">quat_wxyz_to_xyzw()</span></code></a>.</p></li>
<li><p>Added <a class="reference internal" href="#roma.utils.rotvec_geodesic_distance" title="roma.utils.rotvec_geodesic_distance"><code class="xref py py-func docutils literal notranslate"><span class="pre">rotvec_geodesic_distance()</span></code></a>.</p></li>
</ul>
</dd>
<dt>Version 1.4.0:</dt><dd><ul class="simple">
<li><p>Added the <a class="reference internal" href="#spatial-transformations"><span class="std std-ref">Spatial transformations</span></a> module.</p></li>
</ul>
</dd>
<dt>Version 1.3.4:</dt><dd><ul class="simple">
<li><p>Use default <cite>torch.svd</cite> with pytorch versions greater than 1.8 (efficiency issue compared to <cite>torch_batch_svd</cite> solved in this PR: <a class="reference external" href="https://github.com/pytorch/pytorch/pull/48436">https://github.com/pytorch/pytorch/pull/48436</a>).</p></li>
</ul>
</dd>
<dt>Version 1.3.3:</dt><dd><ul class="simple">
<li><p><a class="reference internal" href="#roma.mappings.procrustes" title="roma.mappings.procrustes"><code class="xref py py-func docutils literal notranslate"><span class="pre">procrustes()</span></code></a> can optionally return singular values, for advanced uses.</p></li>
<li><p><a class="reference internal" href="#roma.utils.rigid_points_registration" title="roma.utils.rigid_points_registration"><code class="xref py py-func docutils literal notranslate"><span class="pre">rigid_points_registration()</span></code></a> and <a class="reference internal" href="#roma.utils.rigid_vectors_registration" title="roma.utils.rigid_vectors_registration"><code class="xref py py-func docutils literal notranslate"><span class="pre">rigid_vectors_registration()</span></code></a> can optionally return scaling estimations.</p></li>
<li><p>Added <code class="xref py py-func docutils literal notranslate"><span class="pre">unitquat_geodesic_distance()</span></code>.</p></li>
</ul>
</dd>
<dt>Version 1.3.2:</dt><dd><ul class="simple">
<li><p>Simplified backpropagation of <a class="reference internal" href="#roma.mappings.procrustes" title="roma.mappings.procrustes"><code class="xref py py-func docutils literal notranslate"><span class="pre">procrustes()</span></code></a>.</p></li>
<li><p>Support for optional weights in <a class="reference internal" href="#roma.utils.rigid_points_registration" title="roma.utils.rigid_points_registration"><code class="xref py py-func docutils literal notranslate"><span class="pre">rigid_points_registration()</span></code></a> and <a class="reference internal" href="#roma.utils.rigid_vectors_registration" title="roma.utils.rigid_vectors_registration"><code class="xref py py-func docutils literal notranslate"><span class="pre">rigid_vectors_registration()</span></code></a>.</p></li>
<li><p>Fix for <a class="reference internal" href="#roma.utils.random_unitquat" title="roma.utils.random_unitquat"><code class="xref py py-func docutils literal notranslate"><span class="pre">random_unitquat()</span></code></a> to support initialization on arbitrary device.</p></li>
</ul>
</dd>
<dt>Version 1.3.1:</dt><dd><ul class="simple">
<li><p>Removed spurious code in <a class="reference internal" href="#roma.mappings.procrustes" title="roma.mappings.procrustes"><code class="xref py py-func docutils literal notranslate"><span class="pre">procrustes()</span></code></a>.</p></li>
<li><p>Replaced warning about missing ‘torch_batch_svd’ module by a test function: <a class="reference internal" href="#roma.utils.is_torch_batch_svd_available" title="roma.utils.is_torch_batch_svd_available"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_torch_batch_svd_available()</span></code></a>.</p></li>
<li><p>Added <a class="reference internal" href="#roma.utils.unitquat_slerp_fast" title="roma.utils.unitquat_slerp_fast"><code class="xref py py-func docutils literal notranslate"><span class="pre">roma.utils.unitquat_slerp_fast()</span></code></a>.</p></li>
<li><p>Improved documentation and tests.</p></li>
</ul>
</dd>
<dt>Version 1.3.0:</dt><dd><ul class="simple">
<li><p>Added <a class="reference internal" href="#roma.utils.quat_action" title="roma.utils.quat_action"><code class="xref py py-func docutils literal notranslate"><span class="pre">roma.utils.quat_action()</span></code></a>.</p></li>
<li><p>Change of underlying algorithm for <a class="reference internal" href="#roma.utils.random_unitquat" title="roma.utils.random_unitquat"><code class="xref py py-func docutils literal notranslate"><span class="pre">random_unitquat()</span></code></a> to avoid potential divisions by 0.</p></li>
<li><p>Fix of <a class="reference internal" href="#roma.utils.unitquat_slerp" title="roma.utils.unitquat_slerp"><code class="xref py py-func docutils literal notranslate"><span class="pre">roma.utils.unitquat_slerp()</span></code></a> which was always performing interpolation along the shortest arc regardless of the value of the <code class="docutils literal notranslate"><span class="pre">shortest_path</span></code> argument (renamed <code class="docutils literal notranslate"><span class="pre">shortest_arc</span></code> in the new version).</p></li>
</ul>
</dd>
<dt>Version 1.2.7:</dt><dd><ul class="simple">
<li><p>Fix of <code class="xref py py-func docutils literal notranslate"><span class="pre">unflatten_batch_dims()</span></code> to ensure compatibility with PyTorch 1.6.0.</p></li>
<li><p>Fix of <code class="xref py py-func docutils literal notranslate"><span class="pre">symmatrixvec_to_unitquat()</span></code> that was not producing a lower triangular matrix.</p></li>
</ul>
</dd>
<dt>Version 1.2.6:</dt><dd><ul class="simple">
<li><p>Added an optional <cite>regularization</cite> argument to <a class="reference internal" href="#roma.mappings.special_procrustes" title="roma.mappings.special_procrustes"><code class="xref py py-func docutils literal notranslate"><span class="pre">special_procrustes()</span></code></a>.</p></li>
<li><p>Added an optional <cite>clamping</cite> argument to <a class="reference internal" href="#roma.utils.rotmat_geodesic_distance" title="roma.utils.rotmat_geodesic_distance"><code class="xref py py-func docutils literal notranslate"><span class="pre">rotmat_geodesic_distance()</span></code></a>.</p></li>
<li><p>Fix: <a class="reference internal" href="#roma.mappings.rotvec_to_rotmat" title="roma.mappings.rotvec_to_rotmat"><code class="xref py py-func docutils literal notranslate"><span class="pre">rotvec_to_rotmat()</span></code></a> no longer produces nonfinite gradient for null rotation vectors.</p></li>
</ul>
</dd>
<dt>Version 1.2.5:</dt><dd><ul class="simple">
<li><p>Added an optional <cite>regularization</cite> argument for Procrustes orthonormalization.</p></li>
<li><p>Added a rigid registration example in the documentation.</p></li>
</ul>
</dd>
<dt>Version 1.2.4:</dt><dd><ul class="simple">
<li><p>Procrustes: automatic fallback to vanilla SVD decomposition for large dimensions.</p></li>
</ul>
</dd>
<dt>Version 1.2.3:</dt><dd><ul class="simple">
<li><p>Improved support for double precision tensors.</p></li>
</ul>
</dd>
<dt>Version 1.2.2:</dt><dd><ul class="simple">
<li><p>Added <a class="reference internal" href="#roma.utils.rigid_points_registration" title="roma.utils.rigid_points_registration"><code class="xref py py-func docutils literal notranslate"><span class="pre">rigid_points_registration()</span></code></a> and <a class="reference internal" href="#roma.utils.rigid_vectors_registration" title="roma.utils.rigid_vectors_registration"><code class="xref py py-func docutils literal notranslate"><span class="pre">rigid_vectors_registration()</span></code></a>.</p></li>
<li><p>Added <a class="reference internal" href="#roma.utils.rotmat_slerp" title="roma.utils.rotmat_slerp"><code class="xref py py-func docutils literal notranslate"><span class="pre">rotmat_slerp()</span></code></a>.</p></li>
<li><p>Circumvented a deprecation warning with <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.symeig()</span></code> when using recent PyTorch versions.</p></li>
</ul>
</dd>
<dt>Version 1.2.1:</dt><dd><ul class="simple">
<li><p>Open-source release.</p></li>
</ul>
</dd>
</dl>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Naver Corp..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>